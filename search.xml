<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>乔布斯</title>
      <link href="/posts/622b42c/"/>
      <url>/posts/622b42c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>艺术与科学,理论与实践.</li><li>把想法变成现实的，才是真正思考过这个想法的。</li><li>思想家和实干家。知行合一。</li></ol><span id="more"></span><div style="width: 360px;"><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_3.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>巴菲特</title>
      <link href="/posts/142ab2b5/"/>
      <url>/posts/142ab2b5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>巴菲特之所以伟大不在于他在75岁拥有450亿美金的财富，而在于他在很年轻的时候想明白很多道理，用一生的岁月来坚守。</p><h1 id="1998年佛罗里达大学演讲"><a href="#1998年佛罗里达大学演讲" class="headerlink" title="1998年佛罗里达大学演讲"></a>1998年佛罗里达大学演讲</h1><ol><li>习惯的枷锁，开始的时候轻的难以察觉，到后来却重的无法摆脱。</li></ol><h2 id="聪明人为什么会做傻事"><a href="#聪明人为什么会做傻事" class="headerlink" title="聪明人为什么会做傻事"></a>聪明人为什么会做傻事</h2><ol><li>为了赚自己不需要的钱，把自己手里的钱把自己需要的钱都搭进去了，这不是傻是什么绝对是傻，不管智商不高都是傻。<strong>为了得到对自己不重要的东西。甘愿拿对自己重要的东西去冒险，哪能这么干，</strong>我不管成功的概率多少还是1000:1, 我都不做这样的事，假如你给我一把枪，里面有1000个子弹，或者说是100万个子弹，只要有一个子弹是真的对着太阳穴打，你给我多少钱我都不会开枪的。要是我赢了，我不需要那些钱，又是我输了，结果不用说了，这样的事我一点都不做，</li><li>一生只富一次<span id="more"></span></li></ol><h2 id="精彩解析"><a href="#精彩解析" class="headerlink" title="精彩解析"></a>精彩解析</h2><div style="width: 360px;"><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/bafeite.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王兴</title>
      <link href="/posts/abdcbc80/"/>
      <url>/posts/abdcbc80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"autoplay":true,"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_2.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>盐铁论</title>
      <link href="/posts/6bb5aa2e/"/>
      <url>/posts/6bb5aa2e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>孙子兵法</title>
      <link href="/posts/f5549be7/"/>
      <url>/posts/f5549be7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><ul><li><strong>谋定而后动：</strong> 谋略是战争的根本，要先做好充分的准备，制定周密的计划，才能取得胜利。</li><li><strong>知己知彼，百战不殆：</strong> 要了解自己和敌人的情况，才能制定有效的作战策略。</li><li><strong>虚实相生：</strong> 要善于运用虚实之势，迷惑敌人，取得主动权。</li><li><strong>攻其不备，出其不意：</strong> 要抓住敌人的弱点，出其不意地发动攻击。</li><li><strong>因敌制胜：</strong> 要根据敌人的情况，灵活地调整作战策略，才能取得胜利。</li></ul><span id="more"></span><h1 id="始计第一"><a href="#始计第一" class="headerlink" title="始计第一"></a>始计第一</h1><h2 id="战争中的欺诈和迷惑战术："><a href="#战争中的欺诈和迷惑战术：" class="headerlink" title="战争中的欺诈和迷惑战术："></a><strong>战争中的欺诈和迷惑战术：</strong></h2><ul><li><p><strong>兵者，诡道也。故能而示之不能，用而示之不用，近而示之远，远而示之近。利而诱之，乱而取之，实而备之，强而避之，怒而挠之，卑而骄之，佚而劳之，亲而离之，攻其无备，出其不意。此兵家之胜，不可先传也。</strong></p></li><li><p>战争是充满欺诈的，要善于隐藏自己的真实实力，迷惑敌人，出其不意地发动攻击。</p></li></ul><h2 id="事先谋划的重要性："><a href="#事先谋划的重要性：" class="headerlink" title="事先谋划的重要性："></a><strong>事先谋划的重要性：</strong></h2><ul><li><p><strong>夫未战而庙算胜者，得算多也；未战而庙算不胜者，得算少也。多算胜少算，而况于无算乎！吾以此观之，胜负见矣。</strong></p></li><li><p>战争要事先做好充分的准备，制定周密的计划，才能取得胜利。</p></li></ul><h1 id="作战第二"><a href="#作战第二" class="headerlink" title="作战第二"></a>作战第二</h1><ul><li><p><strong>故兵贵胜，不贵久。</strong></p></li><li><p>战争贵在取胜，不在于持久。</p></li></ul><h1 id="谋攻第三"><a href="#谋攻第三" class="headerlink" title="谋攻第三"></a>谋攻第三</h1><ul><li><strong>不战而屈人之兵是最高策略：</strong> 孙子认为，战争是最后的手段，最好的策略是通过谋略和外交手段使敌人屈服，避免战争的发生。</li><li><strong>伐谋是最高层次的用兵策略：</strong> 孙子将用兵策略分为四个层次：伐谋、伐交、伐兵、攻城，其中伐谋是最重要的，即通过策略和计谋使敌人主动投降。</li><li><strong>知己知彼是取胜的关键：</strong> 孙子认为，战争的胜负取决于对敌我双方的了解和对形势的判断。他提出了五点取胜之道：知己知彼、识众寡之用、上下同欲、以虞待不虞、将能而君不御。</li><li><strong>将领是国家安危的决定者：</strong> 孙子强调了将领在战争中的重要作用，认为将领要能够根据情况灵活运用兵法，避免縻军和乱军引胜的错误。</li></ul><h1 id="军形第四"><a href="#军形第四" class="headerlink" title="军形第四"></a>军形第四</h1><p><strong>先为不可胜，以待敌之可胜</strong></p><p><strong>先为不可胜，以待敌之可胜。不可胜在己，可胜在敌。故善战者，能为不可胜，不能使敌之必可胜。故曰：胜可知，而不可为。</strong></p><ul><li><strong>不可胜在己</strong>：优秀的将领首先要确保自己立于不败之地，这取决于自身的准备和防御。</li><li><strong>可胜在敌</strong>：胜利的机会则是由敌人的错误或弱点决定的。</li><li><strong>胜可知，而不可为</strong>：胜利的条件可以被预知，但不能强行制造。</li></ul><h1 id="兵势第五"><a href="#兵势第五" class="headerlink" title="兵势第五"></a>兵势第五</h1><p><strong>凡战者，以正合，以奇胜。</strong></p><ul><li><strong>以正合</strong>：用常规的战术进行交战。</li><li><strong>以奇胜</strong>：用出其不意的战术取得胜利。</li></ul><h1 id="虚实第六"><a href="#虚实第六" class="headerlink" title="虚实第六"></a>虚实第六</h1><p><strong>故善战者，致人而不致于人。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaEE技能树</title>
      <link href="/posts/f1b25278/"/>
      <url>/posts/f1b25278/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h1><p><img src="/../images/WX20240413-160908.png" alt="WX20240413-160908.png"></p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> JAVAEE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-04日记</title>
      <link href="/posts/42a306ee/"/>
      <url>/posts/42a306ee/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="5ccee6c0b60e239d1f8857609a0f2455aff67ff9211616bf778e3e124597d4f8">e6394f24cbc4b9c257a947e9735531ad08a3446c3c84a9d00b6eae5909cf293f146048ce73638583913e0501e468534034057e0e193891fad2388612f7731166073910ed811252225fc81de297ee7b23684bf0111ec8501f7610387b1894bc4d297da6ba09b0422463e1e2b5a72aff8e9d2599d9fb34f0f81a48a81ae9f4c8e286a642f41c666ad46697b097c8b9a222da9bf869e27afc95699902da7e4b01796f1cbae0e5d8ba7cf14aac019f4a3f0210487bc850c3050568acd234ed60ed305d35cf714ad8586a2fdeb969af3c3719bd877d168ef2af3633951c5e1ab723918d1d174606400ec89694b8d22ed464ce766be2407f0f0747285e70f681f6a8c69027d187637767694571ca33c6184e37fc399a4f9534965d7a36606448dbf89f895481ad01d43147623c63ac14123339e30ee30a07a475d3ed612b7171dc79ecba919dfb032b285d1f3a9f654f9f6d7bb489e19261cc4f040da1dd0b7e960de59997313218c20c6df9efd7f6494bd7ac6f1198de36da1fd2a6fff29d6a304f7631492d867047cc7fad0d46e72c0aacef3a99b3e22b18371236fd06beb5f577df7a7a9365335dc6a36c6b867bc2c13c02bace9c272cbc94d0143f9c286ad908a1157393ecd33f1da196529f281e4153e9514cfea46abe8fad8c7a79a63db0ac2a4bf84e76fcb4f4e4de2f3f4b346fe35e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spirng基础</title>
      <link href="/posts/3fed9f30/"/>
      <url>/posts/3fed9f30/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC 控制反转"></a>IOC 控制反转</h1><ol><li>IOC控制反转，全称（Inversion of Control）是一种设计理念。</li><li>IOC的目的是降低对象之间直接耦合。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）</li><li>由代理人来创建和管理对象，消费者通过代理人来获取对象。</li><li>加入IOC容器将对象统一管理，让对象关联变为弱耦合。</li></ol><p><img src="/../images/1957695-da23d0a0760c6e7e.webp" alt="1957695-da23d0a0760c6e7e.webp"><br><img src="/../images/1957695-bdb55bb000ae89ec.webp" alt="1957695-bdb55bb000ae89ec.webp"></p><span id="more"></span><h1 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h1><ol><li>IOC是设计理念,是现代程序设计遵循的标准,是宏观目标。</li><li>Dl(Dependency Injection)是具体技术实现,是微观实现。</li><li>狭义的Spring是指Spring框架(Spring Framework)</li><li>广义的Spring是指Spring生态体系</li></ol><h1 id="狭义的Spring框架"><a href="#狭义的Spring框架" class="headerlink" title="狭义的Spring框架"></a>狭义的Spring框架</h1><ol><li><p>Spring框架是企业开发复杂性的一站式解决方案</p></li><li><p>Spring框架的核心是IOC容器与AOP面向切面编程</p></li><li><p>Spring IOC负责创建与管理系统对象，并在此基础上扩展功能</p></li><li><p>DI在Java中利用反射技术实现对象注入(Injection)</p></li></ol><h1 id="Spring的含义"><a href="#Spring的含义" class="headerlink" title="Spring的含义"></a>Spring的含义</h1><ol><li>Spring可从狭义与广义两个角度看待</li></ol><h1 id="广义的Spring生态体系"><a href="#广义的Spring生态体系" class="headerlink" title="广义的Spring生态体系"></a>广义的Spring生态体系</h1><p><img src="/../images/WX20240402-181512.png" alt="WX20240402-181512.png"></p><h1 id="IOC-和传统开发对比"><a href="#IOC-和传统开发对比" class="headerlink" title="IOC 和传统开发对比"></a>IOC 和传统开发对比</h1><ol><li>对象直接引用导致对象硬性关联，程序难以扩展维护。</li><li>IOC容器是Spring生态的基地，用于统一创建与管理对象依赖。</li></ol><p><img src="/../images/WX20240402-191505@2x.png" alt="WX20240402-191505@2x.png"><br><img src="/../images/WX20240402-191652@2x.png" alt="WX20240402-191652@2x.png"></p><h1 id="Spring-IOC容器职责"><a href="#Spring-IOC容器职责" class="headerlink" title="Spring IOC容器职责"></a>Spring IOC容器职责</h1><ol><li>对象的控制权交由第三方统一管理（IOC控制反转）</li><li>利用Java反射技术实现运行时对象创建与关联（DI依赖注入）</li><li>基于配置提高应用程序的可维护性与扩展性</li></ol><h1 id="初始化IOC容器"><a href="#初始化IOC容器" class="headerlink" title="初始化IOC容器"></a>初始化IOC容器</h1><h2 id="XML管理对象（Bean）"><a href="#XML管理对象（Bean）" class="headerlink" title="XML管理对象（Bean）"></a>XML管理对象（Bean）</h2><p>有以下三种方式</p><ol><li>基于XML配置Bean</li><li>基于注解配置Bean</li><li>基于Java代码配置Bean</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.jianshu.com/p/07af9dbbbc4b">控制反转（IoC）与依赖注入（DI）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVAEE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Application的理解</title>
      <link href="/posts/ea5de885/"/>
      <url>/posts/ea5de885/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Application的生命周期"><a href="#Application的生命周期" class="headerlink" title="Application的生命周期"></a>Application的生命周期</h1><ol><li>构造函数</li><li>attachBaseContext</li><li>onCreate</li></ol><span id="more"></span><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>不要在Application的生命周期中做耗时操作，因为Application的生命周期都是在UI线程中进行的，Application初始化完成之后，就会立即初始化四大组件，要是我们在Application的生命周期中做了耗时操作，就会阻塞四大组件的初始化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Context的理解</title>
      <link href="/posts/4c51f887/"/>
      <url>/posts/4c51f887/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="context是什么？"><a href="#context是什么？" class="headerlink" title="context是什么？"></a>context是什么？</h1><p>Context 意为上下文，是一个应用程序环境信息的接口。通过Context可以访问系统资源，系统服务等。</p><h1 id="应用中一共有几个-Context-对象"><a href="#应用中一共有几个-Context-对象" class="headerlink" title="应用中一共有几个 Context 对象"></a>应用中一共有几个 Context 对象</h1><p>Context数量 &#x3D; Activity + Service + Application;</p><span id="more"></span><h1 id="Context的继承关系"><a href="#Context的继承关系" class="headerlink" title="Context的继承关系"></a>Context的继承关系</h1><ol><li>Activity和UI相关继承了ContextThemeWrapper</li></ol><p><img src="/../images/690292-20171124104943125-199635726.png" alt="690292-20171124104943125-199635726.png"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓UI体系</title>
      <link href="/posts/c17ff4c4/"/>
      <url>/posts/c17ff4c4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Surface跨进程传递"><a href="#Surface跨进程传递" class="headerlink" title="Surface跨进程传递"></a>Surface跨进程传递</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-----&gt; /frameworks/native/libs/gui/SurfaceControl.<span class="function">cpp</span></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::getSurface</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateSurfaceLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::generateSurfaceLocked</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn&#x27;t matter; using false.</span></span><br><span class="line">    <span class="comment">//使用GraphicBufferProducer创建了一个Surface</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> <span class="built_in">Surface</span>(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>surface它只是一个壳子，而不是buffer对象，surface里面包含了一个能生产buffer的binder对象，也就是GraphicBufferProducer。</li><li>surface跨进程传递，本质是GraphicBufferProducer的传递</li></ol><span id="more"></span><h1 id="Surface的绘制原理"><a href="#Surface的绘制原理" class="headerlink" title="Surface的绘制原理"></a>Surface的绘制原理</h1><h2 id="Surface的Buffer是从怎么来的？"><a href="#Surface的Buffer是从怎么来的？" class="headerlink" title="Surface的Buffer是从怎么来的？"></a>Surface的Buffer是从怎么来的？</h2><p>&#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;include&#x2F;gui&#x2F;BufferQueueCore.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mSlots is an array of buffer slots that must be mirrored on the producer</span></span><br><span class="line">    <span class="comment">// side. This allows buffer ownership to be transferred between the producer</span></span><br><span class="line">    <span class="comment">// and consumer without sending a GraphicBuffer over Binder. The entire</span></span><br><span class="line">    <span class="comment">// array is initialized to NULL at construction time, and buffers are</span></span><br><span class="line">    <span class="comment">// allocated for a slot when requestBuffer is called with that slot&#x27;s index.    //  typedef BufferSlot SlotsType[NUM_BUFFER_SLOTS];    //  static constexpr int NUM_BUFFER_SLOTS = 64;</span></span><br><span class="line">    BufferQueueDefs::SlotsType mSlots;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mQueue is a FIFO of queued buffers used in synchronous mode.</span></span><br><span class="line">    Fifo mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mFreeSlots contains all of the slots which are FREE and do not currently</span></span><br><span class="line">    <span class="comment">// have a buffer attached.</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mFreeSlots;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mFreeBuffers contains all of the slots which are FREE and currently have</span></span><br><span class="line">    <span class="comment">// a buffer attached.</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mFreeBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mUnusedSlots contains all slots that are currently unused. They should be</span></span><br><span class="line">    <span class="comment">// free and not have a buffer attached.</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mUnusedSlots;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mActiveBuffers contains all slots which have a non-FREE buffer attached.</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mActiveBuffers;</span><br></pre></td></tr></table></figure><ol><li>通过mGaphicBufferProducer-&gt;dequeteBuffer()函数在远端的BufferQueue的Buffer slots中获得一个空闲的Buffer，返回远端Buffer地址指针。</li></ol><p><img src="/../images/170b835110e4f3aa~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp" alt="170b835110e4f3aa~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp"></p><h2 id="buffer是如何提交的？"><a href="#buffer是如何提交的？" class="headerlink" title="buffer是如何提交的？"></a>buffer是如何提交的？</h2><ol><li>通过mGraphicBufferProducer-&gt;queueBuffer(i, )函数，将本地的Buffer同步到远端Buffer queue中。</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.cnblogs.com/naray/p/15363076.html">Android之Surface绘制原理 </a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/posts/92933cdb/"/>
      <url>/posts/92933cdb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AOP-底层技术比较"><a href="#AOP-底层技术比较" class="headerlink" title="AOP 底层技术比较"></a>AOP 底层技术比较</h1><p><img src="/../images/WX20240401-094133@2x.png" alt="WX20240401-094133@2x.png"></p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio</title>
      <link href="/posts/737f3f95/"/>
      <url>/posts/737f3f95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="阿里镜像"><a href="#阿里镜像" class="headerlink" title="阿里镜像"></a>阿里镜像</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/central&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/jcenter&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/google&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://jitpack.io&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UI渲染优化</title>
      <link href="/posts/e0219194/"/>
      <url>/posts/e0219194/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UI-优化的常用手段"><a href="#UI-优化的常用手段" class="headerlink" title="UI 优化的常用手段"></a>UI 优化的常用手段</h1><h2 id="尽量使用硬件加速"><a href="#尽量使用硬件加速" class="headerlink" title="尽量使用硬件加速"></a>尽量使用硬件加速</h2><h2 id="Create-View-优化"><a href="#Create-View-优化" class="headerlink" title="Create View 优化"></a>Create View 优化</h2><ol><li><p>View 的创建也是在 UI 线程里。</p></li><li><p>View 创建的耗时，可能会包括各种 XML 的随机读的 I&#x2F;O 时间、解析 XML 的时间、生成对象的时间（Framework 会大量使用到反射）。</p></li></ol><span id="more"></span><p><strong>1. 使用代码创建</strong></p><p><strong>2. 异步创建</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(12).png" alt="下载 (12).png"></p><p>在创建完 View 后我们需要把线程的 Looper 恢复成原来的。</p><p><strong>3. View 重用</strong></p><h2 id="measure-layout-优化"><a href="#measure-layout-优化" class="headerlink" title="measure&#x2F;layout 优化"></a>measure&#x2F;layout 优化</h2><ol><li><p>减少 UI 布局层次。例如尽量扁平化，使用<ViewStub> <Merge>等优化。</p></li><li><p>优化 layout 的开销。尽量不使用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大。这里我推荐使用 ConstraintLayout 替代 RelativeLayout 或者 weighted LinearLayout。</p></li><li><p>背景优化。尽量不要重复去设置背景，这里需要注意的是主题背景（theme)， theme 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景我们来说是无用的。但是由于主题背景是设置在 DecorView 中，所以这里会带来重复绘制，也会带来绘制性能损耗。</p></li></ol><p>Textview 是系统控件中非常强大也非常重要的一个控件，强大的背后就代表着需要做很多计算。在 2018 年的 Google I&#x2F;O 大会，发布了PrecomputedText并已经集成在 Jetpack 中，它给我们提供了接口，可以异步进行 measure 和 layout，不必在主线程中执行。</p><h1 id="UI-优化的进阶手段"><a href="#UI-优化的进阶手段" class="headerlink" title="UI 优化的进阶手段"></a>UI 优化的进阶手段</h1><h2 id="Litho"><a href="#Litho" class="headerlink" title="Litho"></a>Litho</h2><p><strong>1. 异步布局</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(13).png" alt="下载 (13).png"></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(14).png" alt="下载 (14).png"></p><p><strong>2. 界面扁平化</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(15).png" alt="下载 (15).png"></p><p>Litho缺点：适合轻量级页面，交互不复杂的。</p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UI渲染</title>
      <link href="/posts/cc16d703/"/>
      <url>/posts/cc16d703/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h1><p>UI 渲染还依赖两个核心的硬件：CPU 与 GPU。UI 组件在绘制到屏幕之前，都需要经过 Rasterization（栅格化）操作，而栅格化操作又是一个非常耗时的操作。GPU（Graphic Processing Unit ）也就是图形处理器，它主要用于处理图形运算，可以帮助我们加快栅格化操作。</p><p>栅格化：指将指令转化为像素的过程。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD.png" alt="下载.png"></p><p>软件绘制使用的是 Skia 库，它是一款能在低端设备如手机上呈现高质量的 2D 跨平台图形框架，类似 Chrome、Flutter 内部使用的都是 Skia 库。</p><span id="more"></span><h1 id="OpenGL-与-Vulkan"><a href="#OpenGL-与-Vulkan" class="headerlink" title="OpenGL 与 Vulkan"></a>OpenGL 与 Vulkan</h1><p>对于硬件绘制，我们通过调用 OpenGL ES 接口利用 GPU 完成绘制。OpenGL是一个跨平台的图形 API，它为 2D&#x2F;3D 图形处理硬件指定了标准软件接口。而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。</p><p>在官方<a href="https://developer.android.com/topic/performance/hardware-accel?hl=zh-cn">硬件加速的文档</a>中，可以看到很多 API 都有相应的 Android API level 限制。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(1).png" alt="下载 (1).png"></p><p>这是为什么呢？其实这主要是受OpenGL ES版本与系统支持的限制，直到最新的 Android P，有 3 个 API 是仍然没有支持。对于不支持的 API，我们需要使用软件绘制模式，渲染的性能将会大大降低。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(2).png" alt="下载 (2).png"></p><p>Android 7.0 把 OpenGL ES 升级到最新的 3.2 版本同时，还添加了对Vulkan的支持。Vulkan 是用于高性能 3D 图形的低开销、跨平台 API。相比 OpenGL ES，Vulkan 在改善功耗、多核优化提升绘图调用上有着非常明显的优势。</p><p>重点关注Vulkan。OpenGL已经不在维护了。</p><h1 id="Android-渲染的演进"><a href="#Android-渲染的演进" class="headerlink" title="Android 渲染的演进"></a>Android 渲染的演进</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(3).png" alt="下载 (3).png"></p><p>一个生动的比喻，如果把应用程序图形渲染过程当作一次绘画过程，那么绘画过程中 Android 的各个图形组件的作用是：</p><ol><li><p>画笔：Skia 或者 OpenGL。我们可以用 Skia 画笔绘制 2D 图形，也可以用 OpenGL 来绘制 2D&#x2F;3D 图形。正如前面所说，前者使用 CPU 绘制，后者使用 GPU 绘制。</p></li><li><p>画纸：Surface。所有的元素都在 Surface 这张画纸上进行绘制和渲染。在 Android 中，Window 是 View 的容器，每个窗口都会关联一个 Surface。而 WindowManager 则负责管理这些窗口，并且把它们的数据传递给 SurfaceFlinger。</p></li><li><p>画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，在 Android 4.1 之前使用的是双缓冲机制；在 Android 4.1 之后，使用的是三缓冲机制。</p></li><li><p>显示：SurfaceFlinger。它将 WindowManager 提供的所有 Surface，通过硬件合成器 Hardware Composer 合成并输出到显示屏。</p></li></ol><h2 id="Android-4-0：开启硬件加速"><a href="#Android-4-0：开启硬件加速" class="headerlink" title="Android 4.0：开启硬件加速"></a>Android 4.0：开启硬件加速</h2><p>在 Android 3.0 之前，或者没有启用硬件加速时，系统都会使用软件方式来渲染 UI。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(4).png" alt="下载 (4).png"></p><ol><li><p>Surface。每个 View 都由某一个窗口管理，而每一个窗口都关联有一个 Surface。</p></li><li><p>Canvas。通过 Surface 的 lock 函数获得一个 Canvas，Canvas 可以简单理解为 Skia 底层接口的封装。</p></li><li><p>Graphic Buffer。SurfaceFlinger 会帮我们托管一个BufferQueue，我们从 BufferQueue 中拿到 Graphic Buffer，然后通过 Canvas 以及 Skia 将绘制内容栅格化到上面。</p></li><li><p>SurfaceFlinger。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFinger，最后硬件合成器 Hardware Composer 合成并输出到显示屏。</p></li></ol><p><strong>硬件加速绘制</strong></p><p>所以从 Androd 3.0 开始，Android 开始支持硬件加速，到 Android 4.0 时，默认开启硬件加速。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(5).png" alt="下载 (5).png"></p><p>硬件加速绘制与软件绘制整个流程差异非常大，最核心就是我们通过 GPU 完成 Graphic Buffer 的内容绘制。此外硬件绘制还引入了一个 DisplayList 的概念，每个 View 内部都有一个 DisplayList，当某个 View 需要重绘时，将它标记为 Dirty。</p><p>当需要重绘时，仅仅只需要重绘一个 View 的 DisplayList，而不是像软件绘制那样需要向上递归。这样可以大大减少绘图的操作数量，因而提高了渲染效率。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(6).png" alt="下载 (6).png"></p><h2 id="Android-4-1：Project-Butter"><a href="#Android-4-1：Project-Butter" class="headerlink" title="Android 4.1：Project Butter"></a>Android 4.1：Project Butter</h2><p>Project Butter 主要包含两个组成部分，一个是 VSYNC，一个是 Triple Buffering。</p><p><strong>VSYNC 信号</strong></p><p>在讲文件 I&#x2F;O 跟网络 I&#x2F;O 的时候，我讲到过中断的概念。对于 Android 4.0，CPU 可能会因为在忙别的事情，导致没来得及处理 UI 绘制。</p><p>为解决这个问题，Project Buffer 引入了VSYNC，它类似于时钟中断。每收到 VSYNC 中断，CPU 会立即准备 Buffer 数据，由于大部分显示设备刷新频率都是 60Hz（一秒刷新 60 次），也就是说一帧数据的准备工作都要在 16ms 内完成。</p><p>这样应用总是在 VSYNC 边界上开始绘制，而 SurfaceFlinger 总是 VSYNC 边界上进行合成。这样可以消除卡顿，并提升图形的视觉表现。</p><p><strong>三缓冲机制 Triple Buffering</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(7).png" alt="下载 (7).png"></p><p>在 Android 4.1 之前，Android 使用双缓冲机制。怎么理解呢？一般来说，不同的 View 或者 Activity 它们都会共用一个 Window，也就是共用同一个 Surface。</p><p>而每个 Surface 都会有一个 BufferQueue 缓存队列，但是这个队列会由 SurfaceFlinger 管理，通过匿名共享内存机制与 App 应用层交互。</p><p>整个流程如下：</p><p>每个 Surface 对应的 BufferQueue 内部都有两个 Graphic Buffer ，一个用于绘制一个用于显示。我们会把内容先绘制到离屏缓冲区（OffScreen Buffer），在需要显示时，才把离屏缓冲区的内容通过 Swap Buffer 复制到 Front Graphic Buffer 中。</p><p>这样 SurfaceFlinge 就拿到了某个 Surface 最终要显示的内容，但是同一时间我们可能会有多个 Surface。这里面可能是不同应用的 Surface，也可能是同一个应用里面类似 SurefaceView 和 TextureView，它们都会有自己单独的 Surface。</p><p>这个时候 SurfaceFlinger 把所有 Surface 要显示的内容统一交给 Hareware Composer，它会根据位置、Z-Order 顺序等信息合成为最终屏幕需要显示的内容，而这个内容会交给系统的帧缓冲区 Frame Buffer 来显示（Frame Buffer 是非常底层的，可以理解为屏幕显示的抽象）。</p><p>如果你理解了双缓冲机制的原理，那就非常容易理解什么是三缓冲区了。如果只有两个 Graphic Buffer 缓存区 A 和 B，如果 CPU&#x2F;GPU 绘制过程较长，超过了一个 VSYNC 信号周期，因为缓冲区 B 中的数据还没有准备完成，所以只能继续展示 A 缓冲区的内容，这样缓冲区 A 和 B 都分别被显示设备和 GPU 占用，CPU 无法准备下一帧的数据。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(8).png" alt="下载 (8).png"></p><p>如果再提供一个缓冲区，CPU、GPU 和显示设备都能使用各自的缓冲区工作，互不影响。简单来说，三缓冲机制就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的了一个 Graphic Buffer 所占用的内存。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(9).png" alt="下载 (9).png"></p><p>对于 VSYNC 信号和 Triple Buffering 更详细的介绍，可以参考<a href="https://blog.csdn.net/innost/article/details/8272867">《Android Project Butter 分析》</a>。</p><h2 id="Android-5-0：RenderThread"><a href="#Android-5-0：RenderThread" class="headerlink" title="Android 5.0：RenderThread"></a>Android 5.0：RenderThread</h2><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(10).png" alt="下载 (10).png"></p><p>在 Android 5.0 引入了两个比较大的改变。一个是引入了 RenderNode 的概念，它对 DisplayList 及一些 View 显示属性做了进一步封装。另一个是引入了 RenderThread，所有的 GL 命令执行都放到这个线程上，渲染线程在 RenderNode 中存有渲染帧的所有信息，可以做一些属性动画，这样即便主线程有耗时操作的时候也可以保证动画流畅。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(11).png" alt="下载 (11).png"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li>20 | UI 优化（上）：UI 渲染的几个关键概念</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节码插桩</title>
      <link href="/posts/cad98d1c/"/>
      <url>/posts/cad98d1c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle</title>
      <link href="/posts/18596a3e/"/>
      <url>/posts/18596a3e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Gradle-插件简介"><a href="#Gradle-插件简介" class="headerlink" title="Gradle 插件简介"></a>Gradle 插件简介</h1><ol><li><p>Gradle是一个构建工具，负责让工程构建变得更自动化。不过它只是一个执行环境，提供了基本的框架，而真正的构建行为不是由他自己去提供的。 Gradle负责在运行的时候，找到所有需要执行的Task，依次来执行。</p></li><li><p>在Gradle的世界中，几乎所有的功能都是以插件的方式去提供的。</p></li><li><p>Gradle 插件则是运行在这套机制上的一些具体构建功能（Task），本质上和 .gradle 文件是相同。例如，我们熟悉的编译 Java 代码的能力，都是由插件提供的。</p></li><li><p>Gradle插件可以提高代码复用性。</p></li></ol><span id="more"></span><h1 id="Gradle插件分类"><a href="#Gradle插件分类" class="headerlink" title="Gradle插件分类"></a>Gradle插件分类</h1><p>Gradle 插件分为 二进制插件 和脚本插件。</p><h1 id="二进制插件使用"><a href="#二进制插件使用" class="headerlink" title="二进制插件使用"></a>二进制插件使用</h1><ol><li>在项目根目录的build.gradle里面声明插件ID与版本号。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">//声明插件ID与版本号</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&quot;com.android.tools.build:gradle:7.1.3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在工程app的build.gradle应用插件和配置插件</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用插件</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置插件</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;30.0.3&quot;</span></span><br><span class="line"></span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="脚本插件的使用"><a href="#脚本插件的使用" class="headerlink" title="脚本插件的使用"></a>脚本插件的使用</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other.gradle 在app目录</span></span><br><span class="line">apply <span class="keyword">from</span>: <span class="string">&#x27;other.gradle&#x27;</span></span><br><span class="line"><span class="comment">// other.gradle 在项目根目录</span></span><br><span class="line">apply <span class="keyword">from</span>:<span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">&quot;other.gradle&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><h2 id="建立buildSrc子工程"><a href="#建立buildSrc子工程" class="headerlink" title="建立buildSrc子工程"></a>建立buildSrc子工程</h2><ol><li><p>在项目根目录建立buildSrc文件夹，名字是Gradle固定的。<br><img src="/../images/WX20240330-193800.png" alt="WX20240330-193800.png"></p></li><li><p>在buildSrc目录下，创建build.gradle文件，并进行工程配置。</p></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用groovy插件，编译插件工程中的代码</span></span><br><span class="line">apply plugin: <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明仓库的地址</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明依赖的包</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建立插件运行入口"><a href="#建立插件运行入口" class="headerlink" title="建立插件运行入口"></a>建立插件运行入口</h2><p><img src="/../images/WX20240330-153412.png" alt="WX20240330-153412.png"></p><ol><li>建立RouterPlugin.groovy入口，并实现apply方法，注入插件的逻辑。</li></ol><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><ol><li>定义Extension,在Gradle目录下建立RouterExtension.groovy文件。并在RouterExtension.groovy定义保存的路径wikiDir。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.router.demo.gradle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RouterExtension &#123;</span><br><span class="line">    String wikiDir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注册Extension。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">void</span> apply(<span class="keyword">Project</span> <span class="keyword">project</span>) &#123;</span><br><span class="line">    <span class="keyword">println</span>(<span class="string">&quot;我来自于 routerPlugin, apply from $&#123;project.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册Extension</span></span><br><span class="line">    <span class="keyword">project</span>.getExtensions().create(<span class="string">&quot;router&quot;</span>, RouterExtension)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用Extension。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    alias(libs.plugins.androidApplication)</span><br><span class="line">    alias(libs.plugins.jetbrainsKotlinAndroid)</span><br><span class="line">    <span class="comment">// 应用插件</span></span><br><span class="line">    alias(libs.plugins.routerPlugin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router &#123;</span><br><span class="line">    wikiDir getRootDir().absolutePath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>获取Extension</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> apply(<span class="keyword">Project</span> <span class="keyword">project</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 获取Extension</span></span><br><span class="line">    <span class="keyword">project</span>.afterEvaluate &#123;</span><br><span class="line">        RouterExtension routerExtension = <span class="keyword">project</span>[<span class="string">&quot;router&quot;</span>]</span><br><span class="line">        <span class="keyword">println</span>(<span class="string">&quot;用户设置的wiki路径:$&#123;routerExtension.wikiDir&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h2><ol><li>在buildSrc目录下的build.gradle 中添加下面的代码。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用maven插件，用于发布</span></span><br><span class="line">apply plugin: <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"><span class="comment">// 配置maven插件中的uploadArchives任务</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">// 设置发布路径为 工程目录下面的repo文件件</span></span><br><span class="line">            repository(url: uri(<span class="string">&#x27;../repo&#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 设置groupId 通常为包名</span></span><br><span class="line">                pom.groupId = <span class="string">&#x27;com.imooc.router&#x27;</span></span><br><span class="line">                <span class="comment">// 设置artifactId, 为当前插件的名称</span></span><br><span class="line">                pom.artifactId = <span class="string">&#x27;router-gradle-plugin&#x27;</span></span><br><span class="line">                <span class="comment">// 设置 插件的版本号</span></span><br><span class="line">                pom.version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>因为不能在buildSrc目录发布，所以 执行<code>cp -rf buildSrc router-gradle-plugin</code>命令，复制buildSrc目录，命名为router-gradle-plugin目录。</li></ol><p><img src="/../images/WX20240330-165955.png" alt="WX20240330-165955.png"></p><ol start="3"><li>在<code>settings.gradle.kts</code>中引入<code>router-gradle-plugin</code>.<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;:app&quot;</span>,<span class="string">&quot;router-gradle-plugin&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>执行<code>./gradlew :router-gradle-plugin:publish --warning-mode all </code>命令发布插件。<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">huawei@huaweideMacBook-Pro ~<span class="regexp">/A/G</span>rdlePlugin [<span class="number">1</span>]&gt; ./gradlew :router-gradle-plugin:publish --warning-mode all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in <span class="number">3</span>s</span><br><span class="line"><span class="number">9</span> actionable tasks: <span class="number">6</span> executed, <span class="number">3</span> up-to-date</span><br><span class="line">huawei@huaweideMacBook-Pro ~<span class="regexp">/A/G</span>rdlePlugin&gt; </span><br></pre></td></tr></table></figure></li></ol><p>生成repo文件夹。</p><p><img src="/../images/WX20240330-180008.png" alt="WX20240330-180008.png"></p><p><a href="https://github.com/shizhongyu/GrdlePlugin">完整代码</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://doc.qzxdp.cn/gradle/8.1.1/userguide/what_is_gradle.html">Gradle文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ANR全面解析</title>
      <link href="/posts/c6084ae/"/>
      <url>/posts/c6084ae/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>解决ANR(Application Not Responding)一直是Android 开发者需要掌握的重要技巧，一般从三个方面着手。</p><ol><li>开发阶段：通过工具检查各个方法的耗时，卡顿情况，发现一处修改一处。</li><li>线上阶段：这个阶段主要依靠监控工具发现ANR并上报，比如matrix。</li><li>分析阶段：如果线上用户发生ANR，并且你获取了一份日志，这就涉及了本文要分享的内容——ANR日志分析技巧。</li></ol><span id="more"></span><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>主线程的消息得不到及时响应。</p><p>很多开发者认为，那就是耗时操作导致ANR，全部是app应用层的问题。实际上，线上环境大部分ANR由系统原因导致。</p><h2 id="应用层导致ANR（耗时操作）"><a href="#应用层导致ANR（耗时操作）" class="headerlink" title="应用层导致ANR（耗时操作）"></a>应用层导致ANR（耗时操作）</h2><ol><li>函数阻塞：如死循环、主线程IO、处理大数据</li><li>锁出错：主线程等待子线程的锁</li><li>内存紧张：系统分配给一个应用的内存是有上限的，长期处于内存紧张，会导致频繁内存交换，进而导致应用的一些操作超时</li></ol><h2 id="系统导致ANR"><a href="#系统导致ANR" class="headerlink" title="系统导致ANR"></a>系统导致ANR</h2><ol><li>CPU被抢占：一般来说，前台在玩游戏，可能会导致你的后台广播被抢占CPU</li><li>系统服务无法及时响应：比如获取系统联系人等，系统的服务都是Binder机制，服务能力也是有限的，有可能系统服务长时间不响应导致ANR</li><li>其他应用占用的大量内存</li></ol><h1 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h1><p>发生ANR的时候，系统会产生一份anr日志文件（手机的&#x2F;data&#x2F;anr 目录下，文件名称可能各厂商不一样，业内大多称呼为trace文件），内含如下几项重要信息。</p><h2 id="CPU-负载"><a href="#CPU-负载" class="headerlink" title="CPU 负载"></a>CPU 负载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Load: <span class="number">2.62</span> / <span class="number">2.55</span> / <span class="number">2.25</span></span><br><span class="line">CPU usage from 0ms to 1987ms <span class="title function_">later</span> <span class="params">(<span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">31</span>:<span class="number">55.169</span> to <span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">32</span>:<span class="number">17.156</span>)</span>:</span><br><span class="line">  <span class="number">41</span>% <span class="number">2080</span>/system_server: <span class="number">28</span>% user + <span class="number">12</span>% kernel / faults: <span class="number">76445</span> minor <span class="number">180</span> major</span><br><span class="line">  <span class="number">26</span>% <span class="number">9378</span>/com.xiaomi.store: <span class="number">20</span>% user + <span class="number">6.8</span>% kernel / faults: <span class="number">68408</span> minor <span class="number">68</span> major</span><br><span class="line">........省略N行.....</span><br><span class="line"><span class="number">66</span>% TOTAL: <span class="number">20</span>% user + <span class="number">15</span>% kernel + <span class="number">28</span>% iowait + <span class="number">0.7</span>% irq + <span class="number">0.7</span>% softirq</span><br></pre></td></tr></table></figure><ol><li>第一行：1、5、15 分钟内正在使用和等待使用CPU 的活动进程的平均数</li><li>第二行：表明负载信息抓取在ANR发生之后的0~1987ms。同时也指明了ANR的时间点：2020-03-10 08:31:55.169</li><li>中间部分：各个进程占用的CPU的详细情况</li><li>最后一行：各个进程合计占用的CPU信息。</li></ol><p>名词解释</p><ol><li>user:用户态,kernel:内核态</li><li>faults:内存缺页，minor——轻微的，major——重度，需要从磁盘拿数据</li><li>iowait:IO使用（等待）占比</li><li>irq:硬中断，softirq:软中断</li></ol><p>注意</p><ol><li>iowait占比很高，意味着有很大可能，是io耗时导致ANR，具体进一步查看有没有进程faults major比较多。</li><li>单进程CPU的负载并不是以100%为上限，而是有几个核，就有百分之几百，如4核上限为400%。</li></ol><h2 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h2><ol><li>Total number of allocations 476778　　进程创建到现在一共创建了多少对象</li><li>Total bytes allocated 52MB　进程创建到现在一共申请了多少内存</li><li>Total bytes freed 52MB　　　进程创建到现在一共释放了多少内存</li><li>Free memory 777KB　　　 不扩展堆的情况下可用的内存</li><li>Free memory until GC 777KB　　GC前的可用内存</li><li>Free memory until OOME 383MB　　OOM之前的可用内存</li><li>Total memory 当前总内存（已用+可用）</li><li>Max memory 384MB  进程最多能申请的内存</li></ol><p>从含义可以得出结论：**Free memory until OOME **的值很小的时候，已经处于内存紧张状态。应用可能是占用了过多内存。</p><p>另外，除了trace文件中有内存信息，普通的eventlog日志中，也有内存信息（不一定打印）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">02</span> <span class="number">22</span>:<span class="number">00</span>:<span class="number">08.195</span>  <span class="number">1531</span>  <span class="number">1544</span> I am_meminfo: [<span class="number">350937088</span>,<span class="number">41086976</span>,<span class="number">492830720</span>,<span class="number">427937792</span>,<span class="number">291887104</span>]</span><br></pre></td></tr></table></figure><p>以上四个值分别指的是：</p><ol><li>Cached</li><li>Free,</li><li>Zram,</li><li>Kernel,Native</li></ol><p>Cached+Free的内存代表着当前整个手机的可用内存，如果值很小，意味着处于内存紧张状态。一般低内存的判定阈值为：4G 内存手机以下阀值：350MB，以上阀值则为：450MB<br>ps:如果ANR时间点前后，日志里有打印onTrimMemory，也可以作为内存紧张的一个参考判断</p><h2 id="堆栈消息"><a href="#堆栈消息" class="headerlink" title="堆栈消息"></a>堆栈消息</h2><p>堆栈信息是最重要的一个信息，展示了ANR发生的进程当前所有线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">suspend all histogram:  Sum: <span class="number">2.</span>834s <span class="number">99</span>% C.I. <span class="number">5.</span>738us-<span class="number">7145.</span>919us Avg: <span class="number">607.</span>155us Max: 41543us</span><br><span class="line">DALVIK <span class="title function_">THREADS</span> <span class="params">(<span class="number">248</span>)</span>:</span><br><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Native</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x74b17080</span> self=<span class="number">0x7bb7a14c00</span></span><br><span class="line">  | sysTid=<span class="number">2080</span> nice=-<span class="number">2</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x7c3e82b548</span></span><br><span class="line">  | state=S schedstat=( <span class="number">757205342094</span> <span class="number">583547320723</span> <span class="number">2145008</span> ) utm=<span class="number">52002</span> stm=<span class="number">23718</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7fdc995000</span>-<span class="number">0x7fdc997000</span> stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  kernel: __switch_to+<span class="number">0xb0</span>/<span class="number">0xbc</span></span><br><span class="line">  kernel: SyS_epoll_wait+<span class="number">0x288</span>/<span class="number">0x364</span></span><br><span class="line">  kernel: SyS_epoll_pwait+<span class="number">0xb0</span>/<span class="number">0x124</span></span><br><span class="line">  kernel: cpu_switch_to+<span class="number">0x38c</span>/<span class="number">0x2258</span></span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">00</span> pc 000000000007cd8c  /system/lib64/libc.so (__epoll_pwait+<span class="number">8</span>)</span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">01</span> pc 0000000000014d48  /system/lib64/libutils.so (android::Looper::pollInner(<span class="type">int</span>)+<span class="number">148</span>)</span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">02</span> pc 0000000000014c18  /system/lib64/libutils.so (android::Looper::pollOnce(<span class="type">int</span>, <span class="type">int</span>*, <span class="type">int</span>*, <span class="keyword">void</span>**)+<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">03</span> pc <span class="number">0000000000127474</span>  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, <span class="type">long</span>, <span class="type">int</span>)+<span class="number">44</span>)</span><br><span class="line">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">  at android.os.MessageQueue.next(MessageQueue.java:<span class="number">330</span>)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:<span class="number">169</span>)</span><br><span class="line">  at com.android.server.SystemServer.run(SystemServer.java:<span class="number">508</span>)</span><br><span class="line">  at com.android.server.SystemServer.main(SystemServer.java:<span class="number">340</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">536</span>)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">856</span>)</span><br><span class="line">   </span><br><span class="line">  ........省略N行.....</span><br><span class="line">   </span><br><span class="line">  <span class="string">&quot;OkHttp ConnectionPool&quot;</span> daemon prio=<span class="number">5</span> tid=<span class="number">251</span> TimedWaiting</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x13daea90</span> self=<span class="number">0x7bad32b400</span></span><br><span class="line">  | sysTid=<span class="number">29998</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x7b7d2614f0</span></span><br><span class="line">  | state=S schedstat=( <span class="number">951407</span> <span class="number">137448</span> <span class="number">11</span> ) utm=<span class="number">0</span> stm=<span class="number">0</span> core=<span class="number">3</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7b7d15e000</span>-<span class="number">0x7b7d160000</span> stackSize=1041KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Object.wait(Native method)</span><br><span class="line">  - waiting on &lt;<span class="number">0x05e5732e</span>&gt; (a com.android.okhttp.ConnectionPool)</span><br><span class="line">  at com.android.okhttp.ConnectionPool$<span class="number">1.</span>run(ConnectionPool.java:<span class="number">103</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x05e5732e</span>&gt; (a com.android.okhttp.ConnectionPool)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1167</span>)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">641</span>)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:<span class="number">764</span>)</span><br></pre></td></tr></table></figure><p>如上日志所示，本文截图了两个线程信息，一个是主线程main，它的状态是native。<br>另一个是OkHttp ConnectionPool，它的状态是TimeWaiting。</p><p>trace文件中的状态是是CPP代码中定义的状态，(不是java的线程状态)下面是一张对应关系表。</p><p><img src="/../images/55ea536a4b3f4108abe5214f8ec15f0d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="55ea536a4b3f4108abe5214f8ec15f0d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><p>由此可知，main函数的native状态是正在执行JNI函数。堆栈信息是我们分析ANR的第一个重要的信息，一般来说：</p><ol><li>main线程处于 BLOCK、WAITING、TIMEWAITING状态，那基本上是函数阻塞导致ANR；</li><li>如果main线程无异常，则应该排查CPU负载和内存环境。</li></ol><h1 id="典型案例分析"><a href="#典型案例分析" class="headerlink" title="典型案例分析"></a>典型案例分析</h1><h2 id="主线程无卡顿，处于正常状态堆栈"><a href="#主线程无卡顿，处于正常状态堆栈" class="headerlink" title="主线程无卡顿，处于正常状态堆栈"></a>主线程无卡顿，处于正常状态堆栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Native</span><br><span class="line">| group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x74b38080</span> self=<span class="number">0x7ad9014c00</span></span><br><span class="line">| sysTid=<span class="number">23081</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x7b5fdc5548</span></span><br><span class="line">| state=S schedstat=( <span class="number">284838633</span> <span class="number">166738594</span> <span class="number">505</span> ) utm=<span class="number">21</span> stm=<span class="number">7</span> core=<span class="number">1</span> HZ=<span class="number">100</span></span><br><span class="line">| stack=<span class="number">0x7fc95da000</span>-<span class="number">0x7fc95dc000</span> stackSize=8MB</span><br><span class="line">| held mutexes=</span><br><span class="line">kernel: __switch_to+<span class="number">0xb0</span>/<span class="number">0xbc</span></span><br><span class="line">kernel: SyS_epoll_wait+<span class="number">0x288</span>/<span class="number">0x364</span></span><br><span class="line">kernel: SyS_epoll_pwait+<span class="number">0xb0</span>/<span class="number">0x124</span></span><br><span class="line">kernel: cpu_switch_to+<span class="number">0x38c</span>/<span class="number">0x2258</span></span><br><span class="line"><span class="keyword">native</span>: #<span class="number">00</span> pc 000000000007cd8c  /system/lib64/libc.so (__epoll_pwait+<span class="number">8</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">01</span> pc 0000000000014d48  /system/lib64/libutils.so (android::Looper::pollInner(<span class="type">int</span>)+<span class="number">148</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">02</span> pc 0000000000014c18  /system/lib64/libutils.so (android::Looper::pollOnce(<span class="type">int</span>, <span class="type">int</span>*, <span class="type">int</span>*, <span class="keyword">void</span>**)+<span class="number">60</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">03</span> pc 00000000001275f4  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, <span class="type">long</span>, <span class="type">int</span>)+<span class="number">44</span>)</span><br><span class="line">at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">at android.os.MessageQueue.next(MessageQueue.java:<span class="number">330</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">169</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7073</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">536</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">876</span>)</span><br></pre></td></tr></table></figure><p>上述主线程堆栈就是一个很正常的空闲堆栈，表明主线程正在等待新的消息。</p><p>如果ANR日志里主线程是这样一个状态，那可能有两个原因：</p><ol><li>该ANR是CPU抢占或内存紧张等其他因素引起</li><li>这份ANR日志抓取的时候，主线程已经恢复正常</li></ol><h2 id="主线程执行耗时操作"><a href="#主线程执行耗时操作" class="headerlink" title="主线程执行耗时操作"></a>主线程执行耗时操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Runnable</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">0</span> dsCount=<span class="number">0</span> flags=<span class="number">0</span> obj=<span class="number">0x72deb848</span> self=<span class="number">0x7748c10800</span></span><br><span class="line">  | sysTid=<span class="number">8968</span> nice=-<span class="number">10</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x77cfa75ed0</span></span><br><span class="line">  | state=R schedstat=( <span class="number">24783612979</span> <span class="number">48520902</span> <span class="number">756</span> ) utm=<span class="number">2473</span> stm=<span class="number">5</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7fce68b000</span>-<span class="number">0x7fce68d000</span> stackSize=8192KB</span><br><span class="line">  | held mutexes= <span class="string">&quot;mutator lock&quot;</span>(shared held)</span><br><span class="line">  at com.example.test.MainActivity$onCreate$<span class="number">2.</span>onClick(MainActivity.kt:<span class="number">20</span>)——关键行！！！</span><br><span class="line">  at android.view.View.performClick(View.java:<span class="number">7187</span>)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:<span class="number">7164</span>)</span><br><span class="line">  at android.view.View.access$<span class="number">3500</span>(View.java:<span class="number">813</span>)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:<span class="number">27640</span>)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:<span class="number">883</span>)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:<span class="number">100</span>)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:<span class="number">230</span>)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7725</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">526</span>)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">1034</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述日志表明，主线程正处于执行状态，看堆栈信息可知不是处于空闲状态，发生ANR是因为一处click监听函数里执行了耗时操作。</p><h2 id="主线程被锁阻塞"><a href="#主线程被锁阻塞" class="headerlink" title="主线程被锁阻塞"></a>主线程被锁阻塞</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Blocked</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x72deb848</span> self=<span class="number">0x7748c10800</span></span><br><span class="line">  | sysTid=<span class="number">22838</span> nice=-<span class="number">10</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x77cfa75ed0</span></span><br><span class="line">  | state=S schedstat=( <span class="number">390366023</span> <span class="number">28399376</span> <span class="number">279</span> ) utm=<span class="number">34</span> stm=<span class="number">5</span> core=<span class="number">1</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7fce68b000</span>-<span class="number">0x7fce68d000</span> stackSize=8192KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.example.test.MainActivity$onCreate$<span class="number">1.</span>onClick(MainActivity.kt:<span class="number">15</span>)</span><br><span class="line">  - waiting to lock &lt;<span class="number">0x01aed1da</span>&gt; (a java.lang.Object) held by thread <span class="number">3</span> ——————关键行！！！</span><br><span class="line">  at android.view.View.performClick(View.java:<span class="number">7187</span>)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:<span class="number">7164</span>)</span><br><span class="line">  at android.view.View.access$<span class="number">3500</span>(View.java:<span class="number">813</span>)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:<span class="number">27640</span>)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:<span class="number">883</span>)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:<span class="number">100</span>)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:<span class="number">230</span>)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7725</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">526</span>)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">1034</span>)</span><br><span class="line">   </span><br><span class="line">  ........省略N行.....</span><br><span class="line">   </span><br><span class="line">  <span class="string">&quot;WQW TEST&quot;</span> prio=<span class="number">5</span> tid=<span class="number">3</span> TimeWating</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x12c44230</span> self=<span class="number">0x772f0ec000</span></span><br><span class="line">  | sysTid=<span class="number">22938</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x77391fbd50</span></span><br><span class="line">  | state=S schedstat=( <span class="number">274896</span> <span class="number">0</span> <span class="number">1</span> ) utm=<span class="number">0</span> stm=<span class="number">0</span> core=<span class="number">1</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x77390f9000</span>-<span class="number">0x77390fb000</span> stackSize=1039KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Thread.sleep(Native method)</span><br><span class="line">  - sleeping on &lt;<span class="number">0x043831a6</span>&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:<span class="number">440</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x043831a6</span>&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:<span class="number">356</span>)</span><br><span class="line">  at com.example.test.MainActivity$onCreate$<span class="number">2</span>$thread$<span class="number">1.</span>run(MainActivity.kt:<span class="number">22</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x01aed1da</span>&gt; (a java.lang.Object)————————————————————关键行！！！</span><br><span class="line">  at java.lang.Thread.run(Thread.java:<span class="number">919</span>)</span><br></pre></td></tr></table></figure><p>这是一个典型的主线程被锁阻塞的例子；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiting to lock &lt;<span class="number">0x01aed1da</span>&gt; (a java.lang.Object) held by thread <span class="number">3</span></span><br></pre></td></tr></table></figure><p>其中等待的锁是&lt;0x01aed1da&gt;，这个锁的持有者是线程 3。进一步搜索 “tid&#x3D;3” 找到线程3， 发现它正在TimeWating。<br>那么ANR的原因找到了：线程3持有了一把锁，并且自身长时间不释放，主线程等待这把锁发生超时。在线上环境中，常见因锁而ANR的场景是SharePreference写入。</p><h2 id="CPU被抢占"><a href="#CPU被抢占" class="headerlink" title="CPU被抢占"></a>CPU被抢占</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from 0ms to 10625ms <span class="title function_">later</span> <span class="params">(<span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">14</span>:<span class="number">38</span>:<span class="number">31.633</span> to <span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">14</span>:<span class="number">38</span>:<span class="number">42.257</span>)</span>:</span><br><span class="line"><span class="number">543</span>% <span class="number">2045</span>/com.alibaba.android.rimet: <span class="number">54</span>% user + <span class="number">89</span>% kernel / faults: <span class="number">4608</span> minor <span class="number">1</span> major ————关键行！！！</span><br><span class="line"><span class="number">99</span>% <span class="number">674</span>/android.hardware.camera.provider@<span class="number">2.4</span>-service: <span class="number">81</span>% user + <span class="number">18</span>% kernel / faults: <span class="number">403</span> minor</span><br><span class="line"><span class="number">24</span>% <span class="number">32589</span>/com.wang.test: <span class="number">22</span>% user + <span class="number">1.4</span>% kernel / faults: <span class="number">7432</span> minor <span class="number">1</span> major</span><br><span class="line">........省略N行.....</span><br></pre></td></tr></table></figure><p>如上日志，第二行是钉钉的进程，占据CPU高达543%，抢占了大部分CPU资源，因而导致发生ANR。</p><p>内存紧张导致ANR<br>如果有一份日志，CPU和堆栈都很正常（不贴出来了），仍旧发生ANR，考虑是内存紧张。<br>从CPU第一行信息可以发现，ANR的时间点是2020-10-31 22:38:58.468—CPU usage from 0ms to 21752ms later (2020-10-31 22:38:58.468 to 2020-10-31 22:39:20.220)<br>接着去系统日志里搜索am_meminfo， 这个没有搜索到。再次搜索onTrimMemory，果然发现了很多条记录；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">19.749</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">33.458</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">00.153</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">58.731</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">02.816</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br></pre></td></tr></table></figure><p>可以看出，在发生ANR的时间点前后，内存都处于紧张状态，level等级是80，查看Android API 文档；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Level for &#123;<span class="doctag">@link</span> #onTrimMemory(int)&#125;: the process is nearing the end</span></span><br><span class="line"><span class="comment">* of the background LRU list, and if more memory isn&#x27;t found soon it will</span></span><br><span class="line"><span class="comment">* be killed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRIM_MEMORY_COMPLETE</span> <span class="operator">=</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure><p>可知80这个等级是很严重的，应用马上就要被杀死，被杀死的这个应用从名字可以看出来是桌面，连桌面都快要被杀死，那普通应用能好到哪里去呢？<br>一般来说，发生内存紧张，会导致多个应用发生ANR，所以在日志中如果发现有多个应用一起ANR了，可以初步判定，此ANR与你的应用无关。</p><h2 id="系统服务超时导致ANR"><a href="#系统服务超时导致ANR" class="headerlink" title="系统服务超时导致ANR"></a>系统服务超时导致ANR</h2><p>系统服务超时一般会包含BinderProxy.transactNative关键字，请看如下日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Native</span><br><span class="line">| group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x727851e8</span> self=<span class="number">0x78d7060e00</span></span><br><span class="line">| sysTid=<span class="number">4894</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x795cc1e9a8</span></span><br><span class="line">| state=S schedstat=( <span class="number">8292806752</span> <span class="number">1621087524</span> <span class="number">7167</span> ) utm=<span class="number">707</span> stm=<span class="number">122</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">| stack=<span class="number">0x7febb64000</span>-<span class="number">0x7febb66000</span> stackSize=8MB</span><br><span class="line">| held mutexes=</span><br><span class="line">kernel: __switch_to+<span class="number">0x90</span>/<span class="number">0xc4</span></span><br><span class="line">kernel: binder_thread_read+<span class="number">0xbd8</span>/<span class="number">0x144c</span></span><br><span class="line">kernel: binder_ioctl_write_read.constprop<span class="number">.58</span>+<span class="number">0x20c</span>/<span class="number">0x348</span></span><br><span class="line">kernel: binder_ioctl+<span class="number">0x5d4</span>/<span class="number">0x88c</span></span><br><span class="line">kernel: do_vfs_ioctl+<span class="number">0xb8</span>/<span class="number">0xb1c</span></span><br><span class="line">kernel: SyS_ioctl+<span class="number">0x84</span>/<span class="number">0x98</span></span><br><span class="line">kernel: cpu_switch_to+<span class="number">0x34c</span>/<span class="number">0x22c0</span></span><br><span class="line"><span class="keyword">native</span>: #<span class="number">00</span> pc 000000000007a2ac  /system/lib64/libc.so (__ioctl+<span class="number">4</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">01</span> pc 00000000000276ec  /system/lib64/libc.so (ioctl+<span class="number">132</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">02</span> pc 00000000000557d4  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+<span class="number">252</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">03</span> pc 0000000000056494  /system/lib64/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, <span class="type">int</span>*)+<span class="number">60</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">04</span> pc 00000000000562d0  /system/lib64/libbinder.so (android::IPCThreadState::transact(<span class="type">int</span>, unsigned <span class="type">int</span>, android::Parcel const&amp;, android::Parcel*, unsigned <span class="type">int</span>)+<span class="number">216</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">05</span> pc 000000000004ce1c  /system/lib64/libbinder.so (android::BpBinder::transact(unsigned <span class="type">int</span>, android::Parcel const&amp;, android::Parcel*, unsigned <span class="type">int</span>)+<span class="number">72</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">06</span> pc 00000000001281c8  /system/lib64/libandroid_runtime.so (???)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">07</span> pc 0000000000947ed4  /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+<span class="number">196</span>)</span><br><span class="line">at android.os.BinderProxy.transactNative(Native method) ————————————————关键行！！！</span><br><span class="line">at android.os.BinderProxy.transact(Binder.java:<span class="number">804</span>)</span><br><span class="line">at android.net.IConnectivityManager$Stub$Proxy.getActiveNetworkInfo(IConnectivityManager.java:<span class="number">1204</span>)—关键行！</span><br><span class="line">at android.net.ConnectivityManager.getActiveNetworkInfo(ConnectivityManager.java:<span class="number">800</span>)</span><br><span class="line">at com.xiaomi.NetworkUtils.getNetworkInfo(NetworkUtils.java:<span class="number">2</span>)</span><br><span class="line">at com.xiaomi.frameworkbase.utils.NetworkUtils.getNetWorkType(NetworkUtils.java:<span class="number">1</span>)</span><br><span class="line">at com.xiaomi.frameworkbase.utils.NetworkUtils.isWifiConnected(NetworkUtils.java:<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>从堆栈可以看出获取网络信息发生了ANR：getActiveNetworkInfo。<br>前文有讲过：系统的服务都是Binder机制（16个线程），服务能力也是有限的，有可能系统服务长时间不响应导致ANR。如果其他应用占用了所有Binder线程，那么当前应用只能等待。<br>可进一步搜索：blockUntilThreadAvailable关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at android.os.Binder.blockUntilThreadAvailable(Native method)</span><br></pre></td></tr></table></figure><p>如果有发现某个线程的堆栈，包含此字样，可进一步看其堆栈，确定是调用了什么系统服务。此类ANR也是属于系统环境的问题，如果某类型机器上频繁发生此问题，应用层可以考虑规避策略。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://juejin.cn/post/6971327652468621326#heading-20">干货：ANR日志分析全面解析</a></li><li><a href="https://www.jianshu.com/p/30c1a5ad63a3">Android应用ANR分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓面试题</title>
      <link href="/posts/b84d2020/"/>
      <url>/posts/b84d2020/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="跨进程传递大图，你能想到哪些方案呢？"><a href="#跨进程传递大图，你能想到哪些方案呢？" class="headerlink" title="跨进程传递大图，你能想到哪些方案呢？"></a>跨进程传递大图，你能想到哪些方案呢？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putBinder(<span class="string">&quot;binder&quot;</span>, <span class="keyword">new</span> <span class="title class_">IRemoteGetBitmap</span>.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bitmap <span class="title function_">getBitMap</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> mBitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">intent.putExtras(bundle);</span><br></pre></td></tr></table></figure><p>较大的 bitmap 直接通过 Intent 传递容易抛异常是因为 Intent 启动组件时，系统禁掉了文件描述符 fd 机制 , bitmap 无法利用共享内存，只能拷贝到 Binder 映射的缓冲区，导致缓冲区超限, 触发异常; 而通过 putBinder 的方式，避免了 Intent 禁用描述符的影响，bitmap 写 parcel 时的 allowFds 默认是 true , 可以利用共享内存，所以能高效传输图片。</p><span id="more"></span><h1 id="Android应用架构设计"><a href="#Android应用架构设计" class="headerlink" title="Android应用架构设计"></a>Android应用架构设计</h1><p><img src="/../images/r5wpOrWfFpzUz4EwIx-jIA.png" alt="r5wpOrWfFpzUz4EwIx-jIA.png"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bitmap全面解析</title>
      <link href="/posts/9f17da40/"/>
      <url>/posts/9f17da40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Bitmap占用内存分析"><a href="#Bitmap占用内存分析" class="headerlink" title="Bitmap占用内存分析"></a>Bitmap占用内存分析</h1><h2 id="res中的图片大小"><a href="#res中的图片大小" class="headerlink" title="res中的图片大小"></a>res中的图片大小</h2><p><img src="/../images/1g0tcd3r383XZE9mYIrKNQ.png" alt="1g0tcd3r383XZE9mYIrKNQ.png"></p><span id="more"></span><p>上图中rodman是保存在res&#x2F;drawable-xhdpi目录下的一张600*600，大小为65Kb的图片。打印结果如下</p><blockquote><p>I&#x2F;Bitmap  ( 5673): bitmap size is 1440000</p></blockquote><p>解释</p><p>默认情况下BitmapFactory使用Bitmap.Config.ARGB_8888的存储方式来加载图片内容，而在这种存储模式下，每一个像素需要占用4个字节。因此上面图片rodman的内存大小可以使用如下公式来计算：</p><blockquote><p>宽<em>高</em> 4 &#x3D; 600 * 600 * 4 &#x3D;1440000</p></blockquote><p>但是如果我们在保证代码不修改的前提下，将图片rodman移动到（注意是移动，不是拷贝）res&#x2F;drawable-hdpi目录下，重新运行代码，则打印日志如下：</p><blockquote><p>I&#x2F;Bitmap  ( 6047): bitmap size is 2560000</p></blockquote><p>可以看出我们只是移动了图片的位置，Bitmap所占用的空间竟然上涨了77%。这是为什么呢？</p><p>实际上BitmapFactory在解析图片的过程中，会根据当前设备屏幕密度和图片所在的drawable目录来做一个对比，根据这个对比值进行缩放操作。具体公式为如下所示</p><ol><li>缩放比例scale &#x3D;当前设备屏幕密度&#x2F;图片所在drawable目录对应屏幕密度</li><li>Bitmap实际大小&#x3D;宽* scale <em>高</em> scale * Config对应存储像素数</li></ol><p>在Android中，各个drawable目录对应的屏幕密度分别为下：</p><p><img src="/../images/P2koli50g9KPTBfb87yqBA.png" alt="P2koli50g9KPTBfb87yqBA.png"></p><p>我运行的设备是Nexus 4，屏幕密度为320。如果将rodman放到drawable-hdpi目录下，最终的计算公式如下：</p><blockquote><p>rodman实际占用内存大小&#x3D; 600 * (320 &#x2F; 240) * 600 * (320 &#x2F; 240) * 4 &#x3D;2560000</p></blockquote><h2 id="assets中的图片大小"><a href="#assets中的图片大小" class="headerlink" title="assets中的图片大小"></a>assets中的图片大小</h2><p>同样是上面的rodman.png，这次将它放到assets目录中，使用如下代码加载：</p><p><img src="/../images/P2koli50g9KPTBfb87yqBA.png" alt="P2koli50g9KPTBfb87yqBA.png"></p><p>最终打印结果如下：</p><blockquote><p>I&#x2F;Bitmap  ( 5673): bitmap size is 1440000</p></blockquote><p>可以看出，加载 assets 目录中的图片，系统并不会对其进行缩放操作。</p><p>assets计算公式  </p><p>Bitmap实际大小 &#x3D; 宽 * 高 * 一像素字节数</p><h1 id="Bitmap-加载优化"><a href="#Bitmap-加载优化" class="headerlink" title="Bitmap 加载优化"></a>Bitmap 加载优化</h1><p><strong>1. 修改图片加载的Config</strong></p><p>将存储方式设置为 Bitmap.Config.RGB_565。这种存储方式一个像素占用 2 个字节，所以最终占用内存直接减半。</p><p><img src="/../images/CgqCHl7GJUyAPcYTAAHDKDnB6wE358.png" alt="CgqCHl7GJUyAPcYTAAHDKDnB6wE358.png"></p><p>打印日志如下:</p><blockquote><p>I&#x2F;Bitmap  ( 6339): bitmap size is 720000</p></blockquote><p><strong>2. inSampleSize</strong></p><p>Options 中还有一个 inSampleSize 参数，可以实现 Bitmap 采样压缩，这个参数的含义是宽高维度上每隔 inSampleSize 个像素进行一次采集。比如以下代码：</p><p><img src="/../images/Ciqc1F7GJVyActI9AAIFtHMpSCo369.png" alt="Ciqc1F7GJVyActI9AAIFtHMpSCo369.png"></p><p>因为宽高都会进行采样，所以最终图片会被缩略 4 倍，最终打印效果如下：</p><blockquote><p>I&#x2F;Bitmap  ( 6414): bitmap size is 180000   &#x2F;&#x2F; 170Kb</p></blockquote><h1 id="Bitmap复用"><a href="#Bitmap复用" class="headerlink" title="Bitmap复用"></a>Bitmap复用</h1><p>场景描述</p><p>如果在 Android 某个页面创建很多个 Bitmap，比如有两张图片 A 和 B，通过点击某一按钮需要在 ImageView 上切换显示这两张图片，实现效果如下所示：</p><p><img src="/../images/Ciqc1F7GJYyACIiCAMbF_4x1vIQ360.gif" alt="Ciqc1F7GJYyACIiCAMbF_4x1vIQ360.gif"></p><p>可以使用以下代码实现上述效果：</p><p><img src="/../images/CgqCHl7GJaqABz77AAIZRUExynU013.png" alt="CgqCHl7GJaqABz77AAIZRUExynU013.png"></p><p>但是在每次调用 switchImage 切换图片时，都需要通过 BitmapFactory 创建一个新的 Bitmap 对象。当方法执行完毕后，这个 Bitmap 又会被 GC 回收，这就造成不断地创建和销毁比较大的内存对象，从而导致频繁 GC（或者叫内存抖动）。像 Android App 这种面相最终用户交互的产品，如果因为频繁的 GC 造成 UI 界面卡顿，还是会影响到用户体验的。可以在 Android Studio Profiler 中查看内存情况，多次切换图片后，显示的效果如下：</p><p><img src="/../images/Ciqc1F7GJbGAX18WAAJGL3irS4A779.png" alt="Ciqc1F7GJbGAX18WAAJGL3irS4A779.png"></p><p><strong>使用 Options.inBitmap 优化</strong></p><p>实际上经过第一次显示之后，内存中已经存在了一个 Bitmap 对象。每次切换图片只是显示的内容不一样，我们可以重复利用已经占用内存的 Bitmap 空间，具体做法就是使用 Options.inBitmap 参数。将 getBitmap 方法修改如下：</p><p><img src="/../images/CgqCHl7GJbmAaThsAAfZxD2Nk4g697.png" alt="CgqCHl7GJbmAaThsAAfZxD2Nk4g697.png"></p><p>解释说明：</p><ol><li>图中 1 处创建一个可以用来复用的 Bitmap 对象。</li><li>图中 2 处，将 options.inBitmap 赋值为之前创建的 reuseBitmap 对象，从而避免重新分配内存。</li></ol><p>重新运行代码，并查看 Profiler 中的内存情况，可以发现不管我们切换图片多少次，内存占用始终处于一个水平线状态。</p><p><img src="/../images/Ciqc1F7GJcCARDsaAAB-hGb9K9w827.png" alt="Ciqc1F7GJcCARDsaAAB-hGb9K9w827.png"></p><p>注意：在上述 getBitmap 方法中，复用 inBitmap 之前，需要调用 canUseForInBitmap 方法来判断 reuseBitmap 是否可以被复用。这是因为 Bitmap 的复用有一定的限制：</p><ol><li>在 Android 4.4 版本之前，只能重用相同大小的 Bitmap 内存区域；</li><li>4.4 之后你可以重用任何 Bitmap 的内存区域，只要这块内存比将要分配内存的 bitmap 大就可以。</li></ol><p>canUserForInBitmap 方法具体如下：</p><p><img src="/../images/CgqCHl7GJciALgl-AAJID6lRHu4721.png" alt="CgqCHl7GJciALgl-AAJID6lRHu4721.png"></p><p>细心的你可能也发现了在每次加载之前，除了 inBitmap 参数之外，我还将 Options.inMutable 置为 true，这里如果不置为 true 的话，BitmapFactory 将不会重复利用 Bitmap 内存，并输出相应 warning 日志：</p><blockquote><p>W&#x2F;BitmapFactory: Unable to reuse an immutable bitmap as an image decoder target.</p></blockquote><h1 id="BitmapRegionDecoder-图片分片显示"><a href="#BitmapRegionDecoder-图片分片显示" class="headerlink" title="BitmapRegionDecoder 图片分片显示"></a>BitmapRegionDecoder 图片分片显示</h1><p>有时候我们想要加载显示的图片很大或者很长，比如手机滚动截图功能生成的图片。</p><p>针对这种情况，在不压缩图片的前提下，不建议一次性将整张图加载到内存，而是采用分片加载的方式来显示图片部分内容，然后根据手势操作，放大缩小或者移动图片显示区域。</p><p>图片分片加载显示主要是使用 Android SDK 中的 BitmapRegionDecoder 来实现。用下面这张图rodman3.png 举例：</p><p><img src="/../images/CgqCHl7GJdyANF1HAACsiTjhRw869.jpeg" alt="CgqCHl7GJdyANF1HAACsiTjhRw869.jpeg"></p><p><strong>BitmapRegionDecoder 基本使用</strong></p><p>首先需要使用 BitmapRegionDecoder 将图片加载到内存中，图片可以以绝对路径、文件描述符、输入流的方式传递给 BitmapRegionDecoder，如下所示：</p><p><img src="/../images/Ciqc1F7GJeeAFD6CAAFug--inhA254.png" alt="Ciqc1F7GJeeAFD6CAAFug--inhA254.png"></p><p>运行后显示效果如下：</p><p><img src="/../images/Ciqc1F7GJe2AX63nAAXfDN4qgKU233.png" alt="Ciqc1F7GJe2AX63nAAXfDN4qgKU233.png"></p><p>在此基础上，我们可以通过自定义View，添加 touch 事件来动态地设置 Bitmap 需要显示的区域 Rect。具体实现网上已经有很多成熟的轮子可以直接使用，比如 LargeImageView 。张鸿洋先生也有一篇比较详细文章对此介绍：Android 高清加载巨图方案。</p><h1 id="Bitmap-缓存"><a href="#Bitmap-缓存" class="headerlink" title="Bitmap 缓存"></a>Bitmap 缓存</h1><p>当需要在界面上同时展示一大堆图片的时候，比如 ListView、RecyclerView 等，由于用户不断地上下滑动，某个 Bitmap 可能会被短时间内加载并销毁多次。这种情况下通过使用适当的缓存，可以有效地减缓 GC 频率保证图片加载效率，提高界面的响应速度和流畅性。</p><p>最常用的缓存方式就是 LruCache，基本使用方式如下：</p><p><img src="/../images/Ciqc1F7GJfaAG6-mAAU9UuZI15w565.png" alt="Ciqc1F7GJfaAG6-mAAU9UuZI15w565.png"></p><p>这个仅做了解，图片加载库已经实现图片缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何跨App启动Activity</title>
      <link href="/posts/7b549679/"/>
      <url>/posts/7b549679/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何启动外部应用的Activity"><a href="#如何启动外部应用的Activity" class="headerlink" title="如何启动外部应用的Activity"></a>如何启动外部应用的Activity</h1><p><strong>1. 共享uid的App</strong></p><p>uid适用于全家桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;com.apkok.android&quot;</span></span><br><span class="line">    android:sharedUserId=<span class="string">&quot;com.apkok&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent().setComponent(ComponentName(<span class="string">&quot;com.apkok.app.b&quot;</span>,<span class="string">&quot;com.apkok.app.b.BActivity&quot;</span>)))</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>2. 使用exported</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AndroidManifest.xml清单文件中：</span><br><span class="line"><span class="comment">// 当exported为true的时候，这种方式是将该Activity暴露在了系统当中，随便哪个应用都可以直接访问该Activity。</span></span><br><span class="line">&lt;activity android:name=<span class="string">&quot;.BActivity&quot;</span> android:exported=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent().setComponent(ComponentName(<span class="string">&quot;com.apkok.app.b&quot;</span>,<span class="string">&quot;com.apkok.app.b.BActivity&quot;</span>)))</span><br></pre></td></tr></table></figure><p><strong>3. 使用intentFilter（隐式启动）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;.BActivity&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;com.apkok.intent.TEST&quot;</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent(<span class="string">&quot;com.apkok.intent.TEST&quot;</span>));</span><br></pre></td></tr></table></figure><h1 id="为允许外部启动的Activity加权限"><a href="#为允许外部启动的Activity加权限" class="headerlink" title="为允许外部启动的Activity加权限"></a>为允许外部启动的Activity加权限</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">App B中的Activity B:</span><br><span class="line"></span><br><span class="line">&lt;permission android:name=<span class="string">&quot;com.apkok.b&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;activity android:name=<span class="string">&quot;.BActivity&quot;</span></span><br><span class="line">    android:permission=<span class="string">&quot;com.apkok.b&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.apkok.intent.TEST&quot;</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">App A中的Activity A:</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;com.apkok.b&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent(<span class="string">&quot;com.apkok.intent.TEST&quot;</span>));</span><br></pre></td></tr></table></figure><p>注意：如果通过权限的方式在App A中的Activity A来启动App B中的Activity B，需要确保App B要比App A先安装，这样的话，在App A中才可以获取到权限，反之亦然。</p><h1 id="拒绝服务漏洞"><a href="#拒绝服务漏洞" class="headerlink" title="拒绝服务漏洞"></a>拒绝服务漏洞</h1><p>场景：App A中的Activity A要启动App B中的Activity B，这样的话，Activity A就是攻击者，Activity B是受害者，在Activity B把自己暴露出来了之后，会出现什么情况呢？</p><p>假设Activity A启动Activity B的时候，传递参数的时候，往Bundle里面扔了一个SerializableA，但SerializableA这个类只在App A里面有，App B里面没有，但我们都知道Bundle在收到数据之后，只要你在Activity B里面去访问了Intent的Extras，它就一定会把里面的数据进行反序列化出来，那么在反序列化的过程当中，如果有一个它不知道的类，那就会抛出一个找不到类的异常，这就是我们通常所说的拒绝服务漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerializableA</span>: Serializable</span><br><span class="line"></span><br><span class="line"><span class="title function_">startActivity</span><span class="params">(Intent(<span class="string">&quot;com.apkok.intent.TEST.B&quot;</span>)</span>.putExtra(<span class="string">&quot;SerializableA&quot;</span>, SerializableA()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// WXEntryActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    SendAuth.<span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendAuth</span>.Resp(intent.getExtras());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码场景是：App A中的Activity A启动微信App进行微信登录授权或使用微信的一些服务的时候，微信会要求我们集成WXEntryActivity类，这个类里面有个handleIntent()方法，方法里面会调用intent.getExtras()方法，这个时候就会将我们传递过来的SerializableA进行反序列化，但在反序列化的过程中，因为微信App里没有SerializableA类，那么就会抛出一个找不到类的异常。</p><p>这种问题如何解决呢？</p><p>Activity中读取Intent的Extras的时候，使用try、catch捕获异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修改WXEntryActivity.java代码：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SendAuth.<span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendAuth</span>.Resp(intent.getExtras());</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ol><li>exported不推荐使用。</li><li>尽量不暴露Activity，为暴露的Activity加权限控制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Activity启动流程</title>
      <link href="/posts/5bb05e10/"/>
      <url>/posts/5bb05e10/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Activity跨进程启动"><a href="#Activity跨进程启动" class="headerlink" title="Activity跨进程启动"></a>Activity跨进程启动</h1><p><img src="/../images/WX20240319-103658@2x.png" alt="WX20240319-103658@2x.png"></p><span id="more"></span><h1 id="Activity进程内启动"><a href="#Activity进程内启动" class="headerlink" title="Activity进程内启动"></a>Activity进程内启动</h1><p><img src="/../images/WX20240319-103831@2x.png" alt="WX20240319-103831@2x.png"></p><h1 id="Activity参数传递"><a href="#Activity参数传递" class="headerlink" title="Activity参数传递"></a>Activity参数传递</h1><p><img src="/../images/WX20240319-111955.png" alt="WX20240319-111955.png"></p><p>同进程可以使用Model。<br>跨进程需要使用ContentProvider。</p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JNI如何实现数据传递？</title>
      <link href="/posts/4df65dfa/"/>
      <url>/posts/4df65dfa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java-Bitmap-和-Native-Bitmap-如何关联"><a href="#java-Bitmap-和-Native-Bitmap-如何关联" class="headerlink" title="java Bitmap 和 Native Bitmap 如何关联"></a>java Bitmap 和 Native Bitmap 如何关联</h1><ol><li>通过在Java层Bitmap.java持有的private final long mNativePtr（指针），这个mNativePtr就是Native层的Bitmap.h&#x2F;cpp的指针。通过指针关联。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java层Native方法</span></span><br><span class="line"><span class="comment">// 该方法用于压缩Bitmap到stream（流）里面。</span></span><br><span class="line"><span class="comment">// nativeBitmap是指针，对应的底层Native函数中的bitmapHandle参数，然后在底层函数中使用bitmapHandle传入到bitmap(bitmapHandle)函数中，获取到对应的底层Bitmap对象，获取到之后就可以操作底层的Bitmap了。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">nativeCompress</span><span class="params">(<span class="type">long</span> nativeBitmap, <span class="type">int</span> format, <span class="type">int</span> quality, OutputStream stream, <span class="type">byte</span>[] tempStorage)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层Native函数</span></span><br><span class="line"><span class="keyword">static</span> jboolean <span class="title function_">Bitmap_compress</span><span class="params">(JNIEnv* env, jobject clazz, jlong bitmapHandle, jint format, jint quality, jobject jstream, jbyteArray jstorage)</span> &#123;</span><br><span class="line">LocalScopeBitmap <span class="title function_">bitmap</span><span class="params">(bitmapHandle)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="DirectBuffer"><a href="#DirectBuffer" class="headerlink" title="DirectBuffer"></a>DirectBuffer</h1><p>DirectBuffer是直接在物理内存上开辟了一块空间，所以对于Java虚拟机来说，可以直接读写它，对于Native层也可以直接读写它，这样的话，就不需要拷贝了，而且拷贝也是需要成本的。</p><p>如下代码所示：</p><p>在Jave层直接往ByteBuffer里面写了一串数值比如1 2 3 4 5 6，在Native层可以直接读，但是要注意字节序的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java虚拟机（ByteBuffer）</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">100</span>);</span><br><span class="line">buffer.putInt(...);</span><br><span class="line">buffer.flip();</span><br><span class="line">NativeCInf.useDirectBuffer(buffer, buffer.limit());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* bufPtr = (<span class="type">int</span>*)env-&gt;GetDirectBufferAddress(buf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; length / sizeof(<span class="type">int</span>); i++) &#123;</span><br><span class="line">    <span class="comment">// bufPtr[i]，此处要注意字节序的问题</span></span><br><span class="line">    LOGI(<span class="string">&quot;useArray: %d&quot;</span>, bufPtr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.cnblogs.com/pengxurui/p/16584683.html">图片系列（6）不同版本上 Bitmap 内存分配与回收原理对比 </a></li><li><a href="https://blog.csdn.net/u011082160/article/details/97912349">Adnroid jni数据传递大全,看这篇就够了</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java的Native方法与底层Native函数是怎么绑定的？</title>
      <link href="/posts/2cc69b3b/"/>
      <url>/posts/2cc69b3b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>静态绑定：通过命名规则映射。<br>动态绑定：通过JNI函数注册。</p><p><img src="/../images/WX20240318-152749.png" alt="WX20240318-152749.png"></p><p>建议通过动态绑定。</p><span id="more"></span><h1 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.apkok.nativec;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeCInf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">callNativeStatic</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------JNI-------------------</span><br><span class="line"></span><br><span class="line">extern <span class="string">&quot;C&quot;</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="comment">// 命名规则：Java_包路径（.统一改为_）_类名_方法名</span></span><br><span class="line"><span class="comment">// 方法参数：</span></span><br><span class="line"><span class="comment">// 1、如果Java Native方法是静态的，对应的底层Native函数的参数就是jclass</span></span><br><span class="line"><span class="comment">// 2、如果Java Native方法是非静态的，对应的底层Native函数的参数就是jobject</span></span><br><span class="line">Java_io_github_apkok_nativec_NativeCInf_callNativeStatic(JNIEnv *,jclass)</span><br></pre></td></tr></table></figure><h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include <span class="string">&quot;log.hpp&quot;</span></span><br><span class="line"> </span><br><span class="line">extern <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"> </span><br><span class="line">    jstring <span class="title function_">stringFromJNI</span><span class="params">(JNIEnv *env, jobject instance)</span> &#123;</span><br><span class="line">        std::<span class="type">string</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    jint <span class="title function_">add</span><span class="params">(JNIEnv *env, jclass clazz, jint a, jint b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    jint <span class="title function_">RegisterNatives</span><span class="params">(JNIEnv *env)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、获取Class</span></span><br><span class="line">        <span class="type">jclass</span> <span class="variable">clazz</span> <span class="operator">=</span> env-&gt;FindClass(<span class="string">&quot;com/afei/jnidemo/MainActivity&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (clazz == NULL) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;con&#x27;t find class: com/afei/jnidemo/MainActivity&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        JNINativeMethod methods_MainActivity[] = &#123;</span><br><span class="line">                &#123;<span class="string">&quot;stringFromJNI&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="keyword">void</span> *) stringFromJNI&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;add&quot;</span>,           <span class="string">&quot;(II)I&quot;</span>,                (<span class="keyword">void</span> *) add&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// int len = sizeof(methods_MainActivity) / sizeof(methods_MainActivity[0]);</span></span><br><span class="line">        <span class="comment">// 2、注册方法</span></span><br><span class="line">        <span class="keyword">return</span> env-&gt;RegisterNatives(clazz, methods_MainActivity,</span><br><span class="line">                                    sizeof(methods_MainActivity) / sizeof(methods_MainActivity[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> &#123;</span><br><span class="line">        JNIEnv *env = NULL;</span><br><span class="line">        <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">jint</span> <span class="variable">result</span> <span class="operator">=</span> RegisterNatives(env);</span><br><span class="line">        LOGD(<span class="string">&quot;RegisterNatives result: %d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>动态绑定可以在任何时刻触发</li><li>动态绑定之前根据静态规则查找Native函数</li><li>动态绑定可以在绑定后的任意时刻取消</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><img src="/../images/WX20240318-153132.png" alt="WX20240318-153132.png"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPU架构适配</title>
      <link href="/posts/2b96b6af/"/>
      <url>/posts/2b96b6af/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="不同CPU架构之间的兼容性"><a href="#不同CPU架构之间的兼容性" class="headerlink" title="不同CPU架构之间的兼容性"></a>不同CPU架构之间的兼容性</h1><ol><li>x86其实是可以在x86_64机器上跑的，所以x86_64兼容x86。 </li><li>armeabi-v7a其实是可以在arm64-v8a机器上跑的，所以arm64_v8a兼容armeabi-v7a。 </li><li>armeabi其实是可以在x86_64、x86、arm64-v8a、armeabi-v7a机器上跑的，所以x86_64、x86、arm64-v8a、armeabi-v7a兼容armeabi。</li></ol><p><img src="/../images/WX20240318-122047.png" alt="WX20240318-122047.png"></p><span id="more"></span><p>例子：</p><p>项目中的libs目录下有以下so库：armeabi（libmath.so、libui.so）、armeabi-v7a（libmath.so、libui.so）、arm64-v8a（libmath.so、libui.so），那么在arm64-v8a的机器上Native库如何加载呢？</p><p>它会优先选择当前CPU对应的CPU架构目录下的so库，也就是会加载arm64-v8a（libmath.so、libui.so）目录下的so库，假设如果arm64-v8a架构的so库里面没有libui.so了，那么会发生什么问题呢？它还是会去arm64-v8a架构的so库里面找，但发现so库里没有libui.so，那么加载就会失败，那刚刚也说了armeabi和armeabi-v7a本身就兼容arm64-v8a，那为什么不去加载它们呢？这是因为CPU加载so库的时候就这么规定的，所以要提供so库就一定要提供一全套，要么就一个都不要提供，这样CPU就会去找它所兼容的so库。</p><h1 id="兼容模式的问题"><a href="#兼容模式的问题" class="headerlink" title="兼容模式的问题"></a>兼容模式的问题</h1><p>1、兼容模式运行的Native库无法获得最优性能（所以x86的电脑上运行arm的虚拟机会很慢！）<br>2、兼容模式容易出现一些难以排查的内存问题<br>3、系统优先加载对应架构目录下的so库</p><h1 id="so库太多如何优化Apk体积"><a href="#so库太多如何优化Apk体积" class="headerlink" title="so库太多如何优化Apk体积"></a>so库太多如何优化Apk体积</h1><h2 id="为App提供不同的CPU架构的Native库"><a href="#为App提供不同的CPU架构的Native库" class="headerlink" title="为App提供不同的CPU架构的Native库"></a>为App提供不同的CPU架构的Native库</h2><p>实际开发过程中，我们不可能提供所有CPU架构的so库，那就要考虑兼容，兼容性最好的当然就是armeabi了，那是不是我们就只需要提供这一套了呢？如果在性能不敏感且无运行时异常的情况下可以这么干。但目前市场上大部分的机器的CPU架构都已经是armeabi-v7a和arm64-v8a了，所以这个时候提供一套兼容性最好的so库就是armeabi-v7a了，所以我们要结合目标用户群体提供合适的架构。</p><p>还有一个方案就是，我们只提供一个CPU架构目录，比如armeabi-v7a，把所需要的so库都扔到这一个目录里面，这样一来里面也可以提供arm64-v8a的so库等，这样的话，我们就可以动态根据当前的CPU架构去选择加载一些特定的so库，微信就是这么干的。</p><p>那到底选择那种方案去提供so库呢？</p><p>最好的办法就是通过线上监控问题，然后针对性提供Native库。</p><p><img src="/../images/WX20240318-143320.png" alt="WX20240318-143320.png"></p><p>对待libmath.so 对性能要求比较高，可以同事提供v7和v8两个。</p><h2 id="优化so体积"><a href="#优化so体积" class="headerlink" title="优化so体积"></a>优化so体积</h2><ol><li>默认隐藏所有符号，只公开必要的（-fvisibility&#x3D;hidden）</li><li>禁用C++ Exception&amp;RTTI（-fno-exception -fno-rtti）</li><li>不要使用iostream，应优先使用Android Log</li><li>使用gc-sections去除无用代码（类似于Java的混淆） LOCAL_CFLAGS +&#x3D; -ffunction-sections -fdata-sections  LOCAL_LDFLAGS +&#x3D; -Wl,–gc-sections</li></ol><h1 id="构建时分包"><a href="#构建时分包" class="headerlink" title="构建时分包"></a>构建时分包</h1><p>根据CPU架构进行分包，每一个包里面只包含一种CPU架构，然后借助应用市场按CPU架构分发安装包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">splits &#123;</span><br><span class="line">    abi &#123;</span><br><span class="line">        enable true</span><br><span class="line">        reset()</span><br><span class="line">        include &quot;armeabi-v7a&quot;、&quot;arm64-v8a&quot;、&quot;x86&quot;、&quot;x86_64&quot;</span><br><span class="line">        universalApk true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SDK开发者应当提供哪些so库"><a href="#SDK开发者应当提供哪些so库" class="headerlink" title="SDK开发者应当提供哪些so库"></a>SDK开发者应当提供哪些so库</h1><ol><li>尽量不在Native层开发，降低问题跟踪维护成本</li><li>尽量优化Native库的体积，降低开发者的使用成本</li><li>必须提供完整的CPU架构依赖</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/posts/7678a22a/"/>
      <url>/posts/7678a22a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型擦除的好处"><a href="#泛型擦除的好处" class="headerlink" title="泛型擦除的好处"></a>泛型擦除的好处</h1><ol><li>运行时内存负担小</li><li>为了向前兼容</li></ol><span id="more"></span><h1 id="类型擦除有哪些问题"><a href="#类型擦除有哪些问题" class="headerlink" title="类型擦除有哪些问题"></a>类型擦除有哪些问题</h1><p><strong>1. 基本类型无法作为泛型参数，会有装箱开箱性能损耗。</strong><br><strong>2. 泛型类型无法用作方法重载。</strong></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 泛型类型无法当做真实类型使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">genericMethod</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">newInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(); <span class="comment">// 错误</span></span><br><span class="line">    T[] arrray = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">0</span>];  <span class="comment">// 错误 </span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> T.class; <span class="comment">// 错误</span></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(); <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">if</span>(list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123; <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 泛型擦除后，无法知道要转换的类型，需要参数传入（Class<T> classOfT）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Class&lt;T&gt; classOfT)</span> <span class="keyword">throws</span> JsonSyntaxException &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> fromJson(json, TypeToken.get(classOfT));</span><br><span class="line">    <span class="keyword">return</span> Primitives.wrap(classOfT).cast(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 静态类型无法引用类泛型参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">max</span><span class="params">(T a, T b)</span>&#123;&#125; <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; R <span class="title function_">max</span><span class="params">(R a, R b)</span>&#123;&#125; <span class="comment">// 正确 声明泛型参数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="签名信息"><a href="#签名信息" class="headerlink" title="签名信息"></a>签名信息</h1><ol><li>可以通过签名信息获取泛型类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Integer&gt;&gt; <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> SubClass.class.getMethod(<span class="string">&quot;getValue&quot;</span>).getGenericReturnType();</span><br><span class="line"><span class="keyword">for</span> (Type type : parameterizedType.getActualTypeArguments()) &#123;</span><br><span class="line">    System.out.printf(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>混淆时保留签名信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes Signature</span><br></pre></td></tr></table></figure><ol start="3"><li>使用泛型签名的两个实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">collectionType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;Collection&lt;Integer&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">Collection&lt;Integer&gt; inits = gson.fromJson(json, collectionType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GitHubService</span> &#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; <span class="title function_">listRepos</span><span class="params">(<span class="meta">@Path(&quot;user&quot;)</span> String user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类</title>
      <link href="/posts/a61b637d/"/>
      <url>/posts/a61b637d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>匿名内部类没有单独的类定义，它在创建对象的同时定义类。</p><span id="more"></span><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(参数列表) &#123;</span><br><span class="line">   <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口() &#123;</span><br><span class="line">   <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类是与new关联的，在创建对象的时候定义类，new后面是父类或者父接口，然后是圆括号()，里面可以是传递给父类构造方法的参数，最后是大括号{}，里面是类的定义。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>)&#123;                </span><br><span class="line">            <span class="meta">@Override</span>                              </span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;             </span><br><span class="line">                <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(x,y));     </span><br><span class="line">            &#125;                                      </span><br><span class="line">        &#125;;                                       </span><br><span class="line">        System.out.println(p.distance());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Point对象的时候，定义了一个匿名内部类，这个类的父类是Point，创建对象的时候，给父类构造方法传递了参数2和3，重写了distance()方法，在方法中访问了外部方法final参数x和y。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>每个匿名内部类也都被生成为了一个独立的类，只是类的名字以外部类加数字编号，没有有意义的名字。上例中，产生了两个类Outer和Outer$1，代码大概如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$1</span>(<span class="built_in">this</span>,<span class="number">2</span>,<span class="number">3</span>,x,y);                                            </span><br><span class="line">        System.out.println(p.distance());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">    <span class="type">int</span> y2;</span><br><span class="line">    Outer outer;</span><br><span class="line">    </span><br><span class="line">    Outer$<span class="number">1</span>(Outer outer, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)&#123;</span><br><span class="line">        <span class="built_in">super</span>(x1,y1);</span><br><span class="line">        <span class="built_in">this</span>.outer = outer;</span><br><span class="line">        <span class="built_in">this</span>.x2 = x2;</span><br><span class="line">        <span class="built_in">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>                              </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;             </span><br><span class="line">        <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="built_in">this</span>.x2,y2));     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>匿名内部类能做的，方法内部类都能做。但如果对象只会创建一次，且不需要构造方法来接受参数，则可以使用匿名内部类，代码书写上更为简洁。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>匿名内部类的构造方法由编译器生成。</p><p><strong>类型一</strong></p><ol><li>匿名内部类所在的方法 是非静态方法， 会引用自己的外部类实例。</li><li>匿名内部类的父类非静态，会引用匿名内部类的父类。</li></ol><p><img src="/../images/b934c4c248844d358b39c042c2c7cf70~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="b934c4c248844d358b39c042c2c7cf70~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><strong>类型二</strong></p><ol><li>必须是final,防止局部变量被修改，造成和匿名内部类的不一致。</li></ol><p><img src="/../images/635bd5f22c2b48868ac412035da23947~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="635bd5f22c2b48868ac412035da23947~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><strong>类型三</strong></p><ol><li>interface跟静态内部类的效果是差不多的， 就是静态的， 也就是不会去引用其外部类的实例。</li></ol><p><img src="/../images/04247078898049c2bb379eed1d792c62~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="04247078898049c2bb379eed1d792c62~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><strong>类型四</strong></p><ol><li>当匿名内部类所在的方法是静态的， 则其构造方法的参数中， 不存在所在方法的最外部类实例了。</li></ol><p><img src="/../images/2171440520f74abdb4da4e2c529379fa~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="2171440520f74abdb4da4e2c529379fa~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><h1 id="Lambda转换（SAM类型）"><a href="#Lambda转换（SAM类型）" class="headerlink" title="Lambda转换（SAM类型）"></a>Lambda转换（SAM类型）</h1><p>一个接口，只有一个抽象方法时，可以用Lambda表达式替换实现；</p><p><img src="/../images/8eb3d7f3f6664a0c80d8167357bd706d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="8eb3d7f3f6664a0c80d8167357bd706d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><img src="/../images/22ae680538d54dccbca8b44204eb8f4d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="22ae680538d54dccbca8b44204eb8f4d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程技能目标</title>
      <link href="/posts/2461e87f/"/>
      <url>/posts/2461e87f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编程语言功底"><a href="#编程语言功底" class="headerlink" title="编程语言功底"></a>编程语言功底</h1><ol><li>你熟悉的语言有哪些亮点特性？</li><li>你能运用这些特性写什么框架？</li></ol><h1 id="android系统原理"><a href="#android系统原理" class="headerlink" title="android系统原理"></a>android系统原理</h1><ol><li>程序是怎么运行的？</li><li>窗口是怎么显示的？</li><li>声音是怎么播放的？</li></ol><span id="more"></span><h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><ol><li>有哪些难点是如何突破的？</li><li>有哪些你失败之处？</li></ol><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><ol><li>为什么选这个方案？</li><li>如何进行模块边界的划分？</li><li>如何实现模块解耦？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-03日记</title>
      <link href="/posts/87043860/"/>
      <url>/posts/87043860/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="fc7dfa5bbc6ae469998e0f9bcb7caa2a7b1a933c1b87e41b6990aa2777e23fe8">e6394f24cbc4b9c257a947e9735531ad08a3446c3c84a9d00b6eae5909cf293f146048ce73638583913e0501e468534034057e0e193891fad2388612f7731166073910ed811252225fc81de297ee7b23684bf0111ec8501f7610387b1894bc4d297da6ba09b0422463e1e2b5a72aff8e9d2599d9fb34f0f81a48a81ae9f4c8e286a642f41c666ad46697b097c8b9a222da9bf869e27afc95699902da7e4b01796f1cbae0e5d8ba7cf14aac019f4a3f0210487bc850c3050568acd234ed60ed305d35cf714ad8586a2fdeb969af3c371948efe89b77cdae372a59bc560c2bd1167feb6da065dde63f83ef437f20abc6dbabb7d63d4cf36daa3be61ae480adf1d2b8bdd60c606d0d96d34c4dd54364edb63761b68a07c7ea1184b345aa29a0c2b7387ddbeb0d9f648f717765f398a4e1128638c08664920225a542dcf2875ed91774d9cec2accffc2ff57239a7e1593106628dc48c1814a3093fbc854e94f402f967e7f5f1863b68319e411652d3e7a95b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/posts/af3eed3c/"/>
      <url>/posts/af3eed3c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认识HTTP"><a href="#认识HTTP" class="headerlink" title="认识HTTP"></a>认识HTTP</h1><ol><li>超文本传输协议 HyperText Transfer Protocol</li><li>最初目的：提供一种发送和接收HTML页面的方法</li><li>版本：HTTP 0.9、1.0、1.1、2.0、3.0</li><li>基于TCP协议</li><li>请求前需要建立TCP连接</li><li>是一个请求响应协议</li><li>客户端发送请求，服务端接收请求，给出响应。</li></ol><span id="more"></span><p><img src="/../images/WX20240307-194042.png" alt="WX20240307-194042.png"></p><h1 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h1><ol><li>使用HTTP协议需要遵守HTTP协议的报文格式</li><li>HTTP协议分为请求报文和响应报文</li><li>请求报文和响应报文分别有自己的格式</li><li>HTTP协议首部采用ASCII编码</li></ol><p>请求报文格式</p><p><img src="/../images/WX20240307-202718.png" alt="WX20240307-202718.png"></p><p>响应报文格式</p><p><img src="/../images/WX20240307-202801.png" alt="WX20240307-202801.png"></p><h1 id="字符集和编码"><a href="#字符集和编码" class="headerlink" title="字符集和编码"></a>字符集和编码</h1><ol><li>将所有需要转换的字符列出来，编上号，形成一张表，就是字符集。</li><li>依据字符集，采用一定的规则，将字符转换成二进制的0和1，就是编码。</li><li>各国家都有自己的字符集和编码，比如GB2312，GBK，big5</li><li>有些编码会兼容ASCII 码，但互相不兼容</li><li>国际上有统一的字符集，如Unicode字符集</li><li>Unicode字符集将全世界所有需要用到的字符列出来，并编号</li><li>可以采用定长编码，将Unicode编号转换成二进制</li><li>使用固定2字节来编码，可能不够用</li><li>使用固定4字节来编码，够用了，但是编码太占用空。</li><li>还可以采用可变长编码，不是直接将Unicode编号转换为二进制</li><li>UTF-8是一种可变长编码</li><li>UTF-8将Unicode 字符集分成4个区间</li><li>0000 0000-0000 007F | 0xxxxxxx</li><li>0000 0080-0000 07FF | 110xxxxx 10xxxxxx</li><li>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</li><li>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</li></ol><p>UTF-8 编码</p><p><img src="/../images/WX20240307-213907.png" alt="WX20240307-213907.png"></p><p>ASCII 编码</p><ol><li>ASCII编码规则很简单</li><li>直接使用字符编号的二进制形式</li><li>H的编号是48（hex）</li><li>i的编号是69（hex）</li><li>Hi的ASCII的编码就是 48 69</li></ol><p><img src="/../images/ascii-1-1.png" alt="ascii-1-1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络分层体系结构</title>
      <link href="/posts/7eb7b9d8/"/>
      <url>/posts/7eb7b9d8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h1><p><img src="/../images/tcpip.png" alt="tcpip.png"></p><span id="more"></span><p><img src="/../images/xrrplcn7zy.webp" alt="xrrplcn7zy.webp"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><ol><li>物理层为上一层数据链路层提供比特流传输服务。</li><li>发送方物理层把0和1在传输介质上用波的形式传输出去。</li><li>接收方物理层按照约定从波形中还原出0和1。</li></ol><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>链路（Link）：从一个节点到相邻节点的一段物理线路（有线或无线），中间没有任何其他的交换节点（主要指路由器）</p><p>数据链路层解决数据包在一个网络或一段链路上传输的问题，主要靠MAC地址。</p><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><ol><li>MAC 地址也叫物理地址，（它是一个用来确认网络设备位置的地址），6字节，是用来唯一标识主机和路由器接口的。</li><li>MAC 地址存在于主机的网卡和者路由器的接口中，全球唯一。</li><li>FF-FF-FF-FF-FF-FF 是广播MAC地址。</li><li>接收端网卡从数据链路层首部拿出目的MAC地址判断是否发给自己。</li></ol><h2 id="数据链路层帧格式"><a href="#数据链路层帧格式" class="headerlink" title="数据链路层帧格式"></a>数据链路层帧格式</h2><p><img src="/../images/ce1c3125a4cf4b57a23da3cc09603f24.png" alt="ce1c3125a4cf4b57a23da3cc09603f24.png"></p><p>类型：标识数据部分使用的是什么协议，比如IP<br>FCS：用于检测帧在传输中是否出现了误码（比特差错）</p><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ol><li>使用集线器可以把多台主机连接在一起</li><li>集线器只工作在物理层</li><li>集线器的每个端口仅简单的转发比特</li><li>每次发送消息，同一网段内所有主机都会收到</li></ol><h2 id="集线器和交换机"><a href="#集线器和交换机" class="headerlink" title="集线器和交换机"></a>集线器和交换机</h2><p><img src="/../images/WX20240301-220916.png" alt="WX20240301-220916.png"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ol><li>网络号相同的主机或路由器接口就处于同一网段或同一个局域网中。</li><li>局域网之间通过路由器相连，形成互联网。</li><li>因特网（Internet）就是最大的互联网。</li></ol><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p><img src="/../images/v2-13c1daebb7b5706a847f4e727d9dacde_r.jpg" alt="v2-13c1daebb7b5706a847f4e727d9dacde_r.jpg"></p><ol><li>只有A，B，C类地址可以分配给网络中的主机或路由器的各接口</li><li>主机号 “全0” 的地址是网路地址，不能分配主机或路由器的各接口</li><li>主机号 “全1” 的地址是广播地址，不能分配主机或路由器的各接口</li><li>A类地址网络号0和127不能分配</li></ol><p>问题：<br>IP地址的分类方式不够灵活，容易造成大量IP地址浪费，因为此时IP地址的网络号和主机号是固定位数的。</p><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><ol><li>从主机号中借用一些比特位作作为子网号划分出不同的子网</li><li>可以使用子网掩码标识出子网的网络号和主机号分别有多少位</li><li>子网掩码：坐起连续的1对应IP中的网络号和子网号，之后的0对应主机号</li><li>将IP地址与对应的子网掩码按位与，就能得到该IP的网络地址</li></ol><p><img src="/../images/WX20240303-141906.png" alt="WX20240303-141906.png"></p><p>默认子网掩码是指在未划分子网的情况下使用的子网掩码</p><ol><li>A类地址 255.0.0.0</li><li>B类地址 255.255.0.0</li><li>C类地址 255.255.255.0</li></ol><p><img src="/../images/WX20240303-143123.png" alt="WX20240303-143123.png"></p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><ol><li>仅从IP地址无法知道网络号和主机号，还需要子网掩码的配合</li><li>可以使用CIDR简化IP和子网掩码的表达</li><li>CIDR：无分类域间路由选择 Classless Inter-Domain-Routing</li><li>消除了A类B类C类地址的概念</li><li>消除了划分子网的概念</li></ol><p>IP：200.10.0.10<br>子网掩码：255.255.255.128<br>CIDR：200.40.0.10&#x2F;25</p><h2 id="同一网络的判断"><a href="#同一网络的判断" class="headerlink" title="同一网络的判断"></a>同一网络的判断</h2><ol><li>通信时，发送方主机用自己的IP地址和自己的子网掩码按位与</li><li>发送方主机再用目的主机的IP地址和自己的子网掩码按位与</li><li>判断目的主机是否与自己在同一网络&#x2F;段</li><li>如果目的主机与自己在同一网络，可以直接向目的主机发送消息</li><li>如果目的主机和自己不在同一网络，需要将消息发送到网关（路由器）</li></ol><h2 id="公网IP和私网IP"><a href="#公网IP和私网IP" class="headerlink" title="公网IP和私网IP"></a>公网IP和私网IP</h2><ol><li>为了缓解IP地址不够用的问题</li><li>公网IP：主要用于局域网，一般各不相同</li><li>私网IP：主要用于局域网，不同网络可以相同</li></ol><p><img src="/../images/v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp" alt="v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp"></p><p><img src="/../images/v2-e2c3a9e6015673ae21920eeeb98aa9c2_720w.webp" alt="v2-e2c3a9e6015673ae21920eeeb98aa9c2_720w.webp"></p><p><img src="/../images/WX20240303-154447.png" alt="WX20240303-154447.png"></p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><ol><li>网络地址转换 Network Address Translation</li><li>在私有网络连接到互联网的路由器上安装NAT软件，称为NAT路由器</li><li>NAT路由器至少有一个有效的公网IP</li><li>NAT路由器会建立公网IP和私有IP的对应关系表</li><li>所有私有网络的主机在和外部通信时，会在NAT路由器上转换成公网IP</li></ol><p>NAT表</p><p><img src="/../images/v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp" alt="v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp"></p><h2 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h2><ol><li>网络地址与端口号转换 Network Address Port Translation</li><li>将NAT转换和运输层端口号结合使用</li><li>使用私有网络的大量主机，可以公用NAPT路由器上1个全球IP地址</li><li>NAPT路由器会建立公网IP 端口号和私有IP 端口号的对应关系表</li><li>所有私有网络的主机在和外部通信时，会在NAPT路由器上转换成公网IP</li></ol><p>NAPT表</p><p><img src="/../images/WX20240303-155943.png" alt="WX20240303-155943.png"></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议的首部格式</p><p><img src="/../images/20171209220259773.png" alt="20171209220259773.png"></p><ol><li>版本：IP协议的版本，一般是版本4</li><li>首部长度：协议首部长度，乘4才是最终长度</li><li>总长度：首部+数据部分长度</li><li>标识：帧的数据部分不超过1500B，过大的IP数据包需要分片，再交给数据链路层，同一数据包的所有分片标识都是一样的。</li><li>标志：是否允许分片，是否是最后一个分片</li><li>片偏移：每一片相对于原数据的字节偏移</li><li>生存时间：路由器收到待转发的IP数据包时，将其首部中的该字段的值减一，若结果不为0就转发，否则就丢弃。</li><li>协议：指明IP数据包的数据载荷是何种协议数据单元。</li><li>首部校验和：用于检测在传输过程中IP首部是否出现了差错。</li><li>填充：使其首部协议长度为4的倍数。</li></ol><p><img src="/../images/WX20240303-181227.png" alt="WX20240303-181227.png"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><ol><li>地址解析协议 Address Resolution Protocol</li><li>通过IP地址获取MAC地址</li><li>同一网络中的主机或路由器接口之间才能使用ARP获取MAC地址。</li><li>主机或路由器拿到目的主机的MAC地址后，会记录在自己的ARP缓存中</li><li>每次通信前都会查看自己的ARP表，没有找到，才会再次发送ARP请求</li></ol><p><img src="/../images/download.png" alt="download.png"></p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><ol><li>网际控制报文协议 Internet Control Message Protocol</li><li>主机或路由器使用ICMP来发送 询问报文和差错报告报文</li><li>常见的询问报文有两种：回送请求和回答，时间戳请求和回答</li><li>ICMP是网络层协议</li><li>ICMP报文被封装在IP数据报中发送</li><li>ICMP报文作为IP数据报的数据载荷</li><li>协议的数据载荷并不一定都是从上一层来的，有的没有上一层</li></ol><p>IMCP 询问报文-回送请求和回答</p><ol><li>由主机或路由器向一个特定的目的的主机或者路由器发出</li><li>收到次报文的主机或路由器必须发送ICMP回送回答报文</li><li>这种询问报文用来测试目的站是否可达以及了解其有关状态</li><li>ping命令使用的就是ICMP询问报文</li></ol><p>ICMP 差错报告报文</p><ol><li>用来向主机或路由器报告差错情况</li><li>常见的差错有：终点不可达，超时等</li><li>tracert命名用于检测IP数据报从源主机到达目的主机要经过哪些路由器</li><li>tracert使用ICMP报文类型有询问报文以及差错报告报文</li></ol><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ol><li>一种具有多个输入端口和输出端口的专用计算机</li><li>在不同网络之间转发数据</li><li>不同网络之间的主机通信，需要路由器</li><li>默认情况下，路由器只知道跟它直连的网络怎么走</li><li>非直连网络需要通过配置静态（手动）或 动态路由（协议）的方式告诉它</li><li>路由表用来记录如何到达某个网络</li><li>数据到来时，路由器会取出目的主机的IP地址</li><li>根据自身的路由表，决定从哪个端口转发出去</li><li>路由器是三层设备（网络层设备）</li></ol><p><img src="/../images/WX20240304-145443.png" alt="WX20240304-145443.png"></p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><ol><li>前三层解决了数据从主机到主机的问题</li><li>实际进行通信的真正实体，是位于通信两端主机的进程</li><li>运输层协议解决数据从进程到进程的问题</li></ol><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ol><li>如何标识不同的应用进程呢</li><li>使用端口号来表示和区分不同的进程</li><li>操作系统会记录各个进程占用（监听）的端口号</li><li>端口号的长度为16比特，取值范围是0-65535</li></ol><p>端口号分类</p><p><img src="/../images/WX20240304-212439.png" alt="WX20240304-212439.png"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><img src="/../images/WX20240304-213826.png" alt="WX20240304-213826.png"></p><p><img src="/../images/2218033471-5cc81004c4449.webp" alt="2218033471-5cc81004c4449.webp"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ol><li>传输控制协议 Transmission Control Protocol</li><li>提供面向连接的可靠传输服务</li><li>传输之前需要先建立连接，传输后需要释放连接</li><li>出现误码，丢失现象会要求重传，重复的会丢弃，乱序数据也会被正确重组</li><li>一般用于可靠传输的应用，例如文件，邮件传输</li><li>TCP是面向字节流的</li><li>会给要传输数据的每一个字节都编号</li></ol><h2 id="TCP协议的可靠传输"><a href="#TCP协议的可靠传输" class="headerlink" title="TCP协议的可靠传输"></a>TCP协议的可靠传输</h2><p><img src="/../images/WX20240305-221315.png" alt="WX20240305-221315.png"></p><p><img src="/../images/WX20240305-221859.png" alt="WX20240305-221859.png"></p><p><img src="/../images/WX20240305-222156.png" alt="WX20240305-222156.png"></p><h2 id="TCP协议首部格式"><a href="#TCP协议首部格式" class="headerlink" title="TCP协议首部格式"></a>TCP协议首部格式</h2><p><img src="/../images/1.png" alt="1.png"></p><p>TCP首部包括20字节的固定首部部分和扩展首部（选项 + 填充），扩展首部最大40字节。<br>20个字节又分为5部分，每部分4个字节32位，如图中的5行，每行表示32位。</p><ol><li>序号：指出本TCP数据载荷第一个字节的序号。</li><li>确认号：对之前收到的所有字节的确认，同时指出期望收到对方下一个TCP数据载荷的第一个字节的序号。比如收到1-5字节的数据，会返回6。</li><li>ACK：只有当ACK为1时，确认号字段才有效。</li><li>数据偏移：指出TCP数据部分的起始处偏移TCP起始处有多远，其实就是TCP的首部长度需乘4</li><li>SYN：用于TCP “三次握手” 建立连接， &#x3D; 1时表明这是一个TCP连接报文</li><li>FIN：用于TCP “四次挥手”释放连接， &#x3D; 1 时表明此TCP的发送方已经将全部数据发送完毕，要求释放TCP连接。</li><li>PSH：推送标志位，提醒接收方取走接受缓冲区的数据</li><li>RST：用于复位TCP连接，&#x3D; 1时表明TCP连接出现严重差错，必须释放连接，让后重新建立连接。</li><li>URG：紧急标志位， &#x3D; 1时，紧急指针字段才有效。</li><li>窗口：用来让对方设置发送窗口的大小，单位为字节。</li><li>紧急指针：指出本TCP数据部分包含了多长的紧急数据，紧急数据之后是普通数据。</li><li>扩展首部：一些扩展功能，如选择确认，窗口扩大，MSS等，填充保证首部长度能被4整除。</li></ol><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ol><li>当发送方发送数据太快，接收方来不及接收，会造成接收方缓存溢出</li><li>接收方会通过TCP报文段的 “窗口” 字段告诉发送方调整发送窗口</li><li>接收方酌情调整发送窗口</li><li>发送窗口&#x3D; min（拥塞窗口，接收窗口）</li></ol><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ol><li>网络中的链路或路由器过载时，会丢弃数据包，这种情况就是网络拥塞</li><li>为了避免拥塞，TCP采用拥塞控制</li><li>拥塞控制采用一系列方法控制拥塞窗口的大小，进而控制发送窗口的大小</li></ol><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><ol><li>SYN表示请求建立连接，</li><li>ACK表示响应</li></ol><p><img src="/../images/WX20240307-122705.png" alt="WX20240307-122705.png"></p><h2 id="释放-TCP-连接"><a href="#释放-TCP-连接" class="headerlink" title="释放 TCP 连接"></a>释放 TCP 连接</h2><ol><li>FIN表示关闭连接</li></ol><p><img src="/../images/WX20240307-145108.png" alt="WX20240307-145108.png"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-02日记</title>
      <link href="/posts/217333d4/"/>
      <url>/posts/217333d4/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="d5c93db51106c727bef2995c6e3da28e050a43e5c323c342786a523a1d89ac73">e6394f24cbc4b9c257a947e9735531ad08a3446c3c84a9d00b6eae5909cf293f146048ce73638583913e0501e468534034057e0e193891fad2388612f7731166073910ed811252225fc81de297ee7b23684bf0111ec8501f7610387b1894bc4d297da6ba09b0422463e1e2b5a72aff8e9d2599d9fb34f0f81a48a81ae9f4c8e286a642f41c666ad46697b097c8b9a222da9bf869e27afc95699902da7e4b01796f1cbae0e5d8ba7cf14aac019f4a3f0210487bc850c3050568acd234ed60ed305d35cf714ad8586a2fdeb969af3c37194d31bf39339abd816bd20a69bd07a0aedb1357f2bfdea6946475cf836cb7834ca05c1ca16fc6c697d856422a8433176fac96a09c4c398ba1349e033d2a196ac21f262893ff29c20533b0ca8d86bb5e6694012fffd00b211db9e5491045c1189ea13e47bf9fed91f645d014d02ad5b6bdf84ae5dc36c16b6bd2bee0ad96c5ea2deabc757e14166753574fc19dcc715db727d39b50903e7c7b90471e4d4b5360394ffd443f2e6367216a32b635de8206ec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解原始类型与对象类型</title>
      <link href="/posts/6b801e23/"/>
      <url>/posts/6b801e23/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原始类型的类型标注"><a href="#原始类型的类型标注" class="headerlink" title="原始类型的类型标注"></a>原始类型的类型标注</h1><p>除了最常见的number &#x2F; string &#x2F; boolean &#x2F; null &#x2F; undefined， ECMAScript 2015（ES6）、2020 (ES11)又分别引入了2个新的原始类型：symbol与bigint 。在TypeScript中它们都有对应的类型注解：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;linbudu&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">male</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">undef</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">nul</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="built_in">object</span> = &#123; name, age, male &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bigintVar1</span>: <span class="built_in">bigint</span> = <span class="number">9007199254740991n</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bigintVar2</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="number">9007199254740991</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">symbolVar</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;unique&#x27;</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h1><p>在JavaScript中，null与undefined分别表示”这里有值，但是个空值”和”这里没有值”。而在TypeScript中，null与undefined类型都是有具体意义的类型。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 strictNullChecks 检查的情况下，会被视作其他类型的子类型，比如string类型会被认为包含了null与undefined类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tmp1</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp2</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp3</span>: <span class="built_in">string</span> = <span class="literal">null</span>; <span class="comment">// 仅在关闭 strictNullChecks 时成立，下同</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp4</span>: <span class="built_in">string</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>用于表示一个独一无二的值。</p><h2 id="Symbol特点："><a href="#Symbol特点：" class="headerlink" title="Symbol特点："></a>Symbol特点：</h2><ol><li>Symbol的值是唯一的，用来解决命名冲突问题</li><li>Symbol值不能与其他数据进行运算</li><li>Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</li></ol><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦吖&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// Symbol(末晨曦吖)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">//symbol</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦吖&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Symbol中的方法"><a href="#Symbol中的方法" class="headerlink" title="Symbol中的方法"></a>Symbol中的方法</h2><h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h3><p>参数是symbol类型的描述信息，不同于Symbol()，这个而参数只能是字符串或者是undefined，若已经创建了则返回这个symbol，否则就进行创建并将这个新的symbol返回，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name === name1);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name === name1);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>请注意，我们在使用创建描述信息为”末晨曦”的变量的时候，使用的是for，而不是Symbol()，倘若使用Symbol()进行首次创建，for会再次创建一次，二者不会相等。<br>原因在于Symbol.for()会有一个登记机制，使用for只会对通过for创建的symbol进行检查，不会对Symbol()创建的进行检查。</p><h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h3><p>这个方法参数是一个通过Symbol.for()创建的symbol类型变量，返回这个symbol变量的描述信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name)); <span class="comment">// &quot;末晨曦&quot;</span></span><br><span class="line"><span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name1)); <span class="comment">// undefined　不能查找Symbol()创建的变量</span></span><br></pre></td></tr></table></figure><h1 id="对象的类型标注"><a href="#对象的类型标注" class="headerlink" title="对象的类型标注"></a>对象的类型标注</h1><p>首先我们使用interface声明一个结构，然后使用这个结构来作为一个对象的类型标注即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDescription</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">male</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">IDescription</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;linbudu&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">599</span>,</span><br><span class="line">    <span class="attr">male</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="修饰接口属性"><a href="#修饰接口属性" class="headerlink" title="修饰接口属性"></a>修饰接口属性</h1><p>在接口结构中通过 ? 来标记一个属性为可选：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDescription</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    male?: <span class="built_in">boolean</span>;</span><br><span class="line">    func?: <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">IDescription</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;linbudu&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">599</span>,</span><br><span class="line">    <span class="attr">male</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 无需实现 func 也是合法的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>readonly 它的作用是防止对象的属性被再次赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDescription</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj3</span>: <span class="title class_">IDescription</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;linbudu&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">599</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法分配到 &quot;name&quot; ，因为它是只读属性</span></span><br><span class="line">obj3.<span class="property">name</span> = <span class="string">&quot;林不渡&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/caihongmin/p/16668774.html">JS第七种数据类型Symbol详解 </a></li></ol>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API简介</title>
      <link href="/posts/51ea29d7/"/>
      <url>/posts/51ea29d7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="API是什么"><a href="#API是什么" class="headerlink" title="API是什么"></a>API是什么</h1><p>API(Application ProgrammingInterface)提供了对某个问题的抽象，以及客户与解决该问题的软件组件之间进行交互的方式。</p><h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><p>接口是开发者所编写的最重要的代码。因为比起相关的实现代码出现问题，修复接口出现的问题代价要大得多。</p><ol><li>修改API时，必须尽可能保证向后兼容。</li><li>出于向后兼容的需求，一定要具有变更控制流程。（如人工审核，代码自动化审核）</li><li>在编写API时，良好的文档和注释必不可少。</li><li>自动化测试同样也很重要。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API特征</title>
      <link href="/posts/33481a84/"/>
      <url>/posts/33481a84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h1><h2 id="可发现性"><a href="#可发现性" class="headerlink" title="可发现性"></a>可发现性</h2><p>可发现的API要求用户能够通过API明白如何使用它们，而不需要参阅任何解释或文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Button 类的方法 setOnClickListener(),表示设置点击监听器,语义清晰。</span><br><span class="line">TextView 类的方法 getText(),表示获取文字内容。</span><br><span class="line">ListView 类方法 getChildAt(<span class="type">int</span> index),参数index表示子项索引位置。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="不易误用"><a href="#不易误用" class="headerlink" title="不易误用"></a>不易误用</h2><blockquote><p>使用枚举类型代替布尔类型，提高代码的可读性。</p></blockquote><p>使用枚举而不是布尔值或整数常量。枚举可以清晰表明参数的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Visibility</span> &#123;</span><br><span class="line">    VISIBLE, INVISIBLE, GONE  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVisibility</span><span class="params">(Visibility visibility)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrientationHelper</span> &#123;</span><br><span class="line">    HORIZONTAL, VERTICAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mLayoutManager.setOrientation(OrientationHelper.VERTICAL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>避免编写拥有多个相同类型参数的函数.</p></blockquote><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createBook</span><span class="params">(String publisher, String illustrator, String author)</span></span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void createBook(Book book)</span><br><span class="line"></span><br><span class="line">Book book = new BookBuilder().withPublisher(...)</span><br><span class="line">                             .withIllustrator(...)</span><br><span class="line">                             .withAuthor(...)</span><br><span class="line">                             .build();</span><br></pre></td></tr></table></figure><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>关于API设计的一致性,主要可以从以下几个方面来理解:</p><p>1.命名一致性 - API中的命名应该保持一致性,如方法名、参数名、返回值等命名要有统一的规范。常见的做法是使用驼峰式命名法等。<br>2.参数格式一致性 - 对于同类方法,其参数格式应保持一致,如查询类方法的分页参数pageSize、pageNum应该统一。<br>3.返回格式一致性 - 对于同类型的返回数据,格式应该保持一致,如都返回JSON格式的数据。<br>4.错误处理一致性 - 对于错误的定义、错误码的命名等都应该保持一致性。<br>5.安全机制一致性 - 如果有认证、授权等安全机制,各个API应该遵循统一的安全规范。<br>6.版本控制一致性 - API的版本控制应该有一致的规范,如使用版本号区分新老版本API等。<br>7.文档规范一致性 - API的文档规范应该保持一致性,如都遵循统一的文档模板等。</p><h2 id="正交"><a href="#正交" class="headerlink" title="正交"></a>正交</h2><blockquote><p>正交的API意味着函数没有副作用。</p></blockquote><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheapMotelShower</span> &#123;</span><br><span class="line">    <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mTemperature;</span><br><span class="line">    <span class="comment">// 水压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mPower;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTemperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetPower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetPower</span><span class="params">(<span class="type">float</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">100</span>)</span><br><span class="line">            p = <span class="number">100</span>;</span><br><span class="line">        mPower = p;</span><br><span class="line">        mTemperature = <span class="number">42.0f</span> + (<span class="type">float</span>) Math.sin(p / <span class="number">38.0f</span>) * <span class="number">45.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SetPower()方法会对GetTemperature()方法的结果产生副作用。在更加复杂的系统中，这种相互依赖性可能会被程序员遗忘，或者被忽视，进而对代码区域的简单地改动就可能对系统其他部分的行为产生的影响。</p><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdealShower</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mTemperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mPower;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTemperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetPower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetTemperature</span><span class="params">(<span class="type">float</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">42</span>)</span><br><span class="line">            t = <span class="number">42</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">85</span>)</span><br><span class="line">            t = <span class="number">85</span>;</span><br><span class="line">        mTemperature = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetPower</span><span class="params">(<span class="type">float</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">100</span>)</span><br><span class="line">            p = <span class="number">100</span>;</span><br><span class="line">        mPower = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计正交API时需要铭记如下两个重要因素</p><ol><li>减少冗余。确保只用一种方式表示相同的信息。每条信息应该只有唯一的权威来源。</li><li>增加独立性。确保暴露的概念没有重叠。任何重叠的概念都应该分解到它们的基础组件中。</li></ol><h1 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h1><blockquote><p>优秀的API表现为松耦合和高内聚。</p></blockquote><ol><li>耦合 给定A和B两个组件，当A改变时需要改变B中多少代码。</li><li>内聚  高内聚是指一个软件模块由相关性很强的代码组成，只负责一项任务。也被称为单一责任原则。</li></ol><h1 id="稳定性、文档详细"><a href="#稳定性、文档详细" class="headerlink" title="稳定性、文档详细"></a>稳定性、文档详细</h1><ol><li>优秀的API设计应该是稳定的且具有前瞻性.<br>稳定并不意味着API不会改变，而是应该将接口版本化，并且在版本升级时保证向后兼容<br>前瞻性表示API应该设计为可扩展的，以便它能优雅的升级而不是被修改得一塌糊涂</li><li>优秀的API设计也应该有很好的文档支持，以便用户获取API的功能、行为、最佳实践以及错误条件的明确信息.</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li>C++ API设计</li><li>如何设计一个优秀的API</li></ol>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络优化</title>
      <link href="/posts/1684077/"/>
      <url>/posts/1684077/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>包体积优化</title>
      <link href="/posts/4767ff81/"/>
      <url>/posts/4767ff81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包体积优化"><a href="#包体积优化" class="headerlink" title="包体积优化"></a>包体积优化</h1><ol><li>针对 dex 的优化，例如 Proguard、dex 的 DebugItem 删除、字节码优化等；</li><li>针对 resource 的优化，例如 AndResGuard、webp 优化等；</li><li>针对 assets 的优化，例如压缩、动态下发等；</li><li>针对 so 的优化，同 assets，另外还有移除调试符号等。</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://tech.meituan.com/2022/06/02/meituans-technical-exploration-and-practice-of-android-so-volume-optimization.html">Android对so体积优化的探索与实践</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程软件</title>
      <link href="/posts/ff82d35e/"/>
      <url>/posts/ff82d35e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Intellij-IDEA-激活"><a href="#Intellij-IDEA-激活" class="headerlink" title="Intellij IDEA 激活"></a>Intellij IDEA 激活</h1><ol><li>Mac</li></ol><p><img src="/../images/20240108152553474203.webp" alt="20240108152553474203.webp"></p><p><img src="/../images/20240108152843416282.webp" alt="20240108152843416282.webp"></p><ol start="2"><li>Win</li></ol><p><img src="/../images/20240108143333072536.webp" alt="20240108143333072536.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SDK</title>
      <link href="/posts/e4a05be2/"/>
      <url>/posts/e4a05be2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编程常用缩写"><a href="#编程常用缩写" class="headerlink" title="编程常用缩写"></a>编程常用缩写</h1><p><a href="https://blog.csdn.net/elegant__/article/details/9748835">https://blog.csdn.net/elegant__&#x2F;article&#x2F;details&#x2F;9748835</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类和接口</title>
      <link href="/posts/15ea71ed/"/>
      <url>/posts/15ea71ed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h1><p><strong>尽可能使每个类或者成员不被外界访问。</strong></p><p>对于成员（字段、方法、嵌套类和嵌套接口）有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：</p><ul><li><p><strong>私有的（private）</strong> ———— 只有在声明该成员的顶层类内部才可以访问这个成员。</p></li><li><p><strong>包级私有的（package-private）</strong> ———— 声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为“缺省（default）”访问级别，如果你没有声明访问修饰符，就是这个访问级别（除了接口的成员，接口成员默认是公有的）。</p></li><li><p><strong>受保护的（protedted）</strong> ———— 声明该成员的类的子类可以访问这个成员（但有一些限制[JLS, 6.6.2]），并且，声明该成员的包内部的任何类也可以访问这个成员。</p></li><li><p><strong>公有的（public）</strong> ———— 在任何地方都可以访问该成员。</p></li></ul><span id="more"></span><p><strong>实例字段决不能是公有的</strong> </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> publicField;  <span class="comment">// 错误的方式，实例字段应该是私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> privateField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrivateField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> privateField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrivateField</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        privateField = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类具有公有的静态 final 数组字段，或者返回这种字段的访问方法，这是错误的。</strong></p><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Potential security hole!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h1><p>为了使类成为不可变类，要遵循一下五条原则：</p><ol><li><strong>不要提供任何修改对象状态的方法（也称为 mutators） 。</strong></li><li><strong>保证类不会被扩展。</strong> 可以将该类声明为final。</li><li><strong>使所有字段都是 final 的。</strong></li><li><strong>使所有的字段都是私有的。</strong></li><li><strong>确保对于任何可变组件的互斥访问。</strong></li></ol><p><strong>不可变对象本质上是线程安全的，它们不要求同步。</strong></p><p><strong>如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。</strong></p><h1 id="组合优先于继承"><a href="#组合优先于继承" class="headerlink" title="组合优先于继承"></a>组合优先于继承</h1><p>继承打破了封装性[Snyder86]。换句话说，子类依赖于其超类中特定功的功能实现。超类的实现有可能会随着版本的不同而有所变化，如果真的发生了变化，子类可能会遭受到破坏，即使它的代码完全没有改变。因而，子类必须跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。</p><h1 id="接口优先于抽象类"><a href="#接口优先于抽象类" class="headerlink" title="接口优先于抽象类"></a>接口优先于抽象类</h1><h1 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constant interface antipattern - do not use!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhysicalConstants</span> &#123;</span><br><span class="line">    <span class="comment">// Avogadro&#x27;s number (1/mol)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">AVOGADROS_NUMBER</span> <span class="operator">=</span> <span class="number">6.022_140_857e23</span>;</span><br><span class="line">    <span class="comment">// Boltzmann constant (J/K)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">BOLTZMANN_CONSTANT</span> <span class="operator">=</span> <span class="number">1.380_648_52e-23</span>;</span><br><span class="line">    <span class="comment">// Mass of the electron (kg)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ELECTRON_MASS</span> <span class="operator">=</span> <span class="number">9.109_383_56e-31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量接口模式是对接口的不良使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对于所有对象都通用的方法</title>
      <link href="/posts/8779c14a/"/>
      <url>/posts/8779c14a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重写-equals-时请遵守通用约定"><a href="#重写-equals-时请遵守通用约定" class="headerlink" title="重写 equals 时请遵守通用约定"></a>重写 equals 时请遵守通用约定</h1><p>重写 equals 方法看起来似乎很简单，但是有许多重写方式会出现错误，而且后果非常严重。最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只能与它自身相等。如果满足了以下任何一个条件，那就是正确的做法：</p><span id="more"></span><ol><li><strong>类的每个实例都是唯一的。</strong> 例如 Thread。Object 提供的 equals 实现对这些类具有完全满足的行为。</li><li><strong>不关心类是否提供了“逻辑相等（logical equality）”的测试功能。</strong> 例如，java.util.regex.Pattern 。</li><li><strong>超类已经重写了 equals，从超类继承过来的行为对于子类也是合适的。</strong> 例如，大多数的 Set 实现都从 AbstractSet 继承 equals 实现，List 实现从 AbstractList 继承 equals 实现，Map 实现从 AbstractMap 继承 equals 实现。</li><li><strong>类是私有的或者是包级私有的，可以确定它的 equals 方法永远不会被调用。</strong></li></ol><p>那么什么时候重写 equals 方法才是合适的呢？当一个类具有逻辑相等的概念时（不同于对象本身相同的概念），而超类还没有重写 equals。 这通常是“值类（value class）”的情况。值类指的是只表示值的类，例如 Integer 或 String。程序猿在利用 equals 方法来比较对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否引用了相同的对象。</p><p><code>to do</code></p><h1 id="当重写-equals-方法时总要重写-hashCode-方法"><a href="#当重写-equals-方法时总要重写-hashCode-方法" class="headerlink" title="当重写 equals 方法时总要重写 hashCode 方法"></a>当重写 equals 方法时总要重写 hashCode 方法</h1><p>相等的对象必须具有相等的散列码（hash code）。</p><h1 id="始终重写-toString-方法"><a href="#始终重写-toString-方法" class="headerlink" title="始终重写 toString 方法"></a>始终重写 toString 方法</h1><p>提供一个好的 toString 实现会使你的类使用起来更加愉快，并使使用该类的系统更容易调试。</p><h1 id="谨慎地重写-clone-方法"><a href="#谨慎地重写-clone-方法" class="headerlink" title="谨慎地重写 clone 方法"></a>谨慎地重写 clone 方法</h1><p><code>to do</code></p><h1 id="考虑实现-Comparable-接口"><a href="#考虑实现-Comparable-接口" class="headerlink" title="考虑实现 Comparable 接口"></a>考虑实现 Comparable 接口</h1>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建和销毁对象</title>
      <link href="/posts/b4ee29f3/"/>
      <url>/posts/b4ee29f3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="考虑静态工厂方法而不是构造函数"><a href="#考虑静态工厂方法而不是构造函数" class="headerlink" title="考虑静态工厂方法而不是构造函数"></a>考虑静态工厂方法而不是构造函数</h1><p><strong>1. 静态工厂方法的一个优点是，它们是有名称的，而构造函数的名称都是一样的。</strong></p><p>如果构造函数的参数本身不能描述返回的对象，那么使用一个精心命名的静态工厂更容易使用，并且生成的客户端代码更容易阅读。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">probablePrime</span><span class="params">(<span class="type">int</span> bitLength, Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitLength &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;bitLength &lt; 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (bitLength &lt; SMALL_PRIME_THRESHOLD ?</span><br><span class="line">            smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) :</span><br><span class="line">            largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在一个类需要使用多个签名、多个构造函数的情况下，用静态工厂方法代替构造函数，并仔细选择方法的名称就可以突出构造函数之间的差异了。</p><p><strong>2. 与构造函数不同，它们不需要在每次被调用时创建一个新对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">TRUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FALSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态工厂方法的第三个优点是，与构造函数不同，它们返回的对象可以是返回类型的任何子类的实例对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Person &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 这里可以改为 return new Player() / Cooker()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class Player <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Class Cooker <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 静态工厂方法的第四个优点是，静态工厂方法所返回的对象的类可以随着每次调用而变化，这取决于静态工厂方法的参数值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="comment">// 抽象类的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="comment">// Apple类的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="comment">// Orange类的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">createFruit</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;apple&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;orange&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid fruit type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 静态工厂方法的第五个优点是，返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在。</strong></p><p>以下是一个简单的示例代码，演示了如何使用服务提供者框架来实现和使用服务：</p><p>首先，定义一个服务接口<code>Shape</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，实现两个不同的形状类<code>Circle</code>和<code>Rectangle</code>，它们都实现了<code>Shape</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，创建一个服务提供者接口<code>ShapeProvider</code>，它定义了一个方法<code>getShape()</code>来获取<code>Shape</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShapeProvider</span> &#123;</span><br><span class="line">    Shape <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，实现两个不同的服务提供者类<code>CircleProvider</code>和<code>RectangleProvider</code>，它们实现了<code>ShapeProvider</code>接口，并分别返回<code>Circle</code>和<code>Rectangle</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleProvider</span> <span class="keyword">implements</span> <span class="title class_">ShapeProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleProvider</span> <span class="keyword">implements</span> <span class="title class_">ShapeProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，创建一个客户端类<code>ShapeClient</code>，它使用服务提供者框架来获取并使用<code>Shape</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ShapeProvider shapeProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShapeClient</span><span class="params">(ShapeProvider shapeProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shapeProvider = shapeProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> shapeProvider.getShape();</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，可以在主函数中使用服务提供者框架来创建<code>ShapeClient</code>实例，并调用<code>drawShape()</code>方法来绘制形状：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShapeProvider</span> <span class="variable">circleProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleProvider</span>();</span><br><span class="line">        <span class="type">ShapeClient</span> <span class="variable">circleClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeClient</span>(circleProvider);</span><br><span class="line">        circleClient.drawShape();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ShapeProvider</span> <span class="variable">rectangleProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectangleProvider</span>();</span><br><span class="line">        <span class="type">ShapeClient</span> <span class="variable">rectangleClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeClient</span>(rectangleProvider);</span><br><span class="line">        rectangleClient.drawShape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，通过使用服务提供者框架，<code>ShapeClient</code>类不需要直接引用具体的形状类&#96;</p><p><strong>6. 静态工厂方法的主要限制在于，类如果不含公有的或者受保护的构造器，就不能被子类化。</strong></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器，不允许直接使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法，用于创建具有指定名称的 Animal 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">createAnimal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法创建公有或受保护的构造器，因为父类 Animal 的构造器是私有的</span></span><br><span class="line">    <span class="comment">// public Dog(String name, String breed) &#123;</span></span><br><span class="line">    <span class="comment">//     super(name);</span></span><br><span class="line">    <span class="comment">//     this.breed = breed;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法创建受保护的构造器，因为父类 Animal 的构造器是私有的</span></span><br><span class="line">    <span class="comment">// protected Dog(String name, String breed) &#123;</span></span><br><span class="line">    <span class="comment">//     super(name);</span></span><br><span class="line">    <span class="comment">//     this.breed = breed;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Animal</code> 类有一个私有的构造器，不允许直接使用。我们使用了一个静态工厂方法 <code>createAnimal</code> 来创建 <code>Animal</code> 实例。</p><p><code>Dog</code> 类继承自 <code>Animal</code> 类，但由于 <code>Animal</code> 类的构造器是私有的，<code>Dog</code> 类无法创建公有或受保护的构造器。因此，<code>Dog</code> 类无法被子类化。</p><p>如果我们想让 <code>Animal</code> 类可以被子类化，就需要提供一个公有的或者受保护的构造器。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 受保护的构造器，允许子类访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法，用于创建具有指定名称的 Animal 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">createAnimal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的构造器，允许直接使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>Dog</code> 类可以被子类化，因为我们提供了一个公有的构造器。</p><p><strong>7. 静态工厂方法的第二个缺点是程序猿很难找到它们。</strong></p><p>通过遵守常见的命名约定来减少此问题。</p><ol><li>from：一种类型转换方法，它接受单个参数并返回此类型的相应实例，例如：<code>Date d = Date.from(instant);</code></li><li>of：一种聚合方法，它接受多个参数并返回包含它们的此类型的实例，例如：<code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</code></li><li>valueOf：一个更详细的替代方案，例如：<code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></li><li>instance or getInstance：返回由其参数（如果有）描述的实例，但不能说它具有相同的值，例如：<code>StackWalker luke = StackWalker.getInstance(options);</code></li><li>create or newInstance：与 instance 或 getInstance 类似，不同之处在于该方法保证每个调用都返回一个新实例，例如：<code>Object newArray = Array.newInstance(classObject, arrayLen);</code></li><li>getType：与 getInstance 类似，是在工厂方法位于不同的类中时使用它。Type 指的是工厂方法返回的对象类型，例如：<code>FileStore fs = Files.getFileStore(path);</code></li><li>newType：与 newInstance 类似，是在工厂方法位于不同的类中时使用它。Type 指的是工厂方法返回的对象类型，例如：<code>BufferedReader br = Files.newBufferedReader(path);</code></li><li>type：获取 Type 和 new Type 一个简明替代的方法，比如：<code>List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</code></li></ol><h1 id="当面临多个参数的构造器时考虑使用构建器"><a href="#当面临多个参数的构造器时考虑使用构建器" class="headerlink" title="当面临多个参数的构造器时考虑使用构建器"></a>当面临多个参数的构造器时考虑使用构建器</h1><p>静态工厂和构造器有个共同的局限性：他们都不能很好地扩展到大量的可选参数。</p><p>下面有个示例，为了简单起见，它显示四个可选域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Telescoping constructor pattern - does not scale well!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize; <span class="comment">// (mL) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings; <span class="comment">// (per container) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories; <span class="comment">// (per serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat; <span class="comment">// (g/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium; <span class="comment">// (mg/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate; <span class="comment">// (g/serving) optional</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbohydrate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.fat = fat;</span><br><span class="line">        <span class="built_in">this</span>.sodium = sodium;</span><br><span class="line">        <span class="built_in">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>重叠构造器模式是可行的，但是当有很多参数的时候就很难编写客户端代码，也很难去阅读它们。</li><li>长串类型相同的参数会导致一些微妙的错误，如果客户端不小心颠倒了其中两个参数的顺序，编译器也不会报错，但是程序在运行的时候就会出现错误的行为。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="comment">// Parameters initialized to default values (if any)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servingSize</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servings</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServingSize</span><span class="params">(<span class="type">int</span> val)</span> &#123; servingSize = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServings</span><span class="params">(<span class="type">int</span> val)</span> &#123; servings = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCalories</span><span class="params">(<span class="type">int</span> val)</span> &#123; calories = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFat</span><span class="params">(<span class="type">int</span> val)</span> &#123; fat = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSodium</span><span class="params">(<span class="type">int</span> val)</span> &#123; sodium = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>();</span><br><span class="line">cocaCola.setServingSize(<span class="number">240</span>);</span><br><span class="line">cocaCola.setServings(<span class="number">8</span>);</span><br><span class="line">cocaCola.setCalories(<span class="number">100</span>);</span><br><span class="line">cocaCola.setSodium(<span class="number">35</span>);</span><br><span class="line">cocaCola.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure><ol><li>JavaBean模式弥补了重叠构造器模式的不足。创建实例很容易，产生的代码读起来也很容易。</li><li>因为构造过程被分到了几个调用中，在构造的过程中 JavaBean 可能处于不一致的状态。无法保证线程安全。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sodium</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">carbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>.Builder(<span class="number">240</span>, <span class="number">8</span>).calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><ol><li>Builder模式结合了重叠构造器的安全性和JavaBean模式的可读性。</li><li>Builder 模式也有缺点。要创建对象，必须先创建其构建器。虽然在实践中创建此构建器的成本可能不太明显，但在性能关键的情况下可能会出现问题。</li></ol><p>建造者模式非常适合用于类层次结构。可以使用并行的建造者层次结构，<br>每个建造者都嵌套在相应的类中。抽象类拥有抽象建造者；具体类拥有具体建造者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder pattern for class hierarchies</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Topping</span> &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Builder</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">addTopping</span><span class="params">(Topping topping)</span> &#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> Pizza <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">        <span class="comment">// Subclasses must override this method to return &quot;this&quot;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">self</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NyPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(Size size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> NyPizza <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NyPizza</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calzone</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">sauceInside</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Default</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sauceInside</span><span class="params">()</span> &#123;</span><br><span class="line">            sauceInside = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> Calzone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Calzone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NyPizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line"><span class="type">Calzone</span> <span class="variable">calzone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>.Builder().addTopping(HAM).sauceInside().build();</span><br></pre></td></tr></table></figure><h1 id="用私有构造器或者枚举类型强化-Singleton-属性"><a href="#用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="用私有构造器或者枚举类型强化 Singleton 属性"></a>用私有构造器或者枚举类型强化 Singleton 属性</h1><p>Singleton 指仅仅被实例化一次的类。</p><p>实现单例的方法有两种。 两者都基于保持构造函数私有并导出公共静态成员以提供对唯一实例的访问。</p><ol><li>第一种</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>readResolve</code>方法是Java中的一个特殊方法，用于在反序列化过程中控制对象的创建。当一个被序列化的对象被反序列化时，会调用该对象的<br><code>readResolve</code>方法来获取要返回的实例。通过在单例类中实现<code>readResolve</code>方法，可以确保反序列化后返回同一个单例对象，从而保持单例属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">    <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三种<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtilityClass</span> &#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">UtilityClass</span><span class="params">(( &#123;</span></span><br><span class="line"><span class="params">        throw new AssertionError()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="避免创建不需要的对象"><a href="#避免创建不需要的对象" class="headerlink" title="避免创建不需要的对象"></a>避免创建不需要的对象</h1><p><strong>错误示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bikini&quot;</span>); <span class="comment">// DON&#x27;T DO THIS!</span></span><br></pre></td></tr></table></figure><p><strong>正确示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;bikini&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>错误示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.matches(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">        + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然String.matches是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能关键的情况下重复使用。问题是它在内部为正则表达式创建了一个 Pattern 实例，<br>并且只使用它一次，之后它就可能会被垃圾回收机制回收。创建 Pattern 实例的代价很大，因为它需要将正则表达式编译为有限状态机</p><p><strong>正确示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RomanNumerals</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ROMAN</span> <span class="operator">=</span> Pattern.compile(</span><br><span class="line">        <span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">        + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 sum 被声明成 Long 而不是 long，意味着程序构造了大约 2^31 个多余的 Long 实例（大约每次往 Long sum 中增加 long 时构造一个实例）。</p><h1 id="清除过期对象的引用"><a href="#清除过期对象的引用" class="headerlink" title="清除过期对象的引用"></a>清除过期对象的引用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can you spot the &quot;memory leak&quot;?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">     * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，每当调用 pop() 方法弹出栈中的一个对象时，实际上是将 size 减小了，<br>但数组 elements 中的对应位置并没有置为 null。因此，被弹出的对象仍然占用着数组的空间，并且栈内部仍然保持着对这些对象的引用。</p><p>正确写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// 将弹出的对象引用置为 null</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="try-with-resources-优先于-try-finally"><a href="#try-with-resources-优先于-try-finally" class="headerlink" title="try-with-resources 优先于 try-finally"></a>try-with-resources 优先于 try-finally</h1><p>Java 库包含许多必须通过调用 close 方法手动关闭的资源。示例包括 InputStream，OutputStream 和 java.sql.Connection。</p><p>在之前的做法中(Historically)，try-finally 语句是保证资源正确关闭的最佳方式，<br>即使出现异常或在 return 的时候(even in the face of an exception or return)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来并不差，但是当你添加第二个资源的时候，它会变得很糟糕：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">            out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使是使用 try-finally 语句关闭资源的正确代码，如前两个代码示例所示，也有一个微妙的缺陷。try 块和 finally 块中的代码都能够抛出异常。例如，在 firstLineOfFile 方法中，对 readLine 的调用可能由于底层物理设备中的故障而引发异常，并且由于相同的原因，对 close 的调用可能会失败。在这种情况下，第二个异常完全覆盖了第一个异常。异常堆栈跟踪中没有第一个异常的记录，这可能会使实际系统中的调试变得非常复杂 - 通常第一个异常才是你要查看并诊断问题的关键所在(usually it’s the first exception that you want to see in order to diagnose the problem)。虽然有可能编写代码来抑制第二个异常而支持第一个异常，但几乎没有人这样做，因为它太冗余了。</p><p>当 Java 7 引入了 try-with-resources 语句[JLS，14.20.3]时，所有这些问题都得到了一并解决。要使用此构造，资源必须实现 AutoCloseable 接口。</p><p>try-with-resources 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// BufferedReader 必须实现 AutoCloseable 接口</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理必须关闭的资源时，相比于 try-finally，始终优先使用 try-with-resources。生成的代码更短更清晰，它生成的异常更有用。try-with-resources 语句可以在使用必须关闭的资源的同同时轻松编写正确的代码，使用 try-finally 几乎是不可能的。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://gitee.com/lixudong1997/effective-java-third-edition">https://gitee.com/lixudong1997/effective-java-third-edition</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> EFFECTIVE JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插件</title>
      <link href="/posts/1562b2a5/"/>
      <url>/posts/1562b2a5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm i <span class="meta">@waline</span>/client</span><br><span class="line">npm install hexo-abbrlink --save</span><br><span class="line">npm install --save hexo-blog-encrypt</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-douban --save</span><br><span class="line">npm install hexo-hide-posts</span><br><span class="line">npm install hexo-lazyload-image --save</span><br><span class="line">npm install hexo-word-counter</span><br><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure><h1 id="查看已经安装的插件"><a href="#查看已经安装的插件" class="headerlink" title="查看已经安装的插件"></a>查看已经安装的插件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list --depth <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github超时解决</title>
      <link href="/posts/89793def/"/>
      <url>/posts/89793def/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IP-映射"><a href="#IP-映射" class="headerlink" title="IP 映射"></a>IP 映射</h1><ol><li><p>找到GithubIP<br><a href="https://sites.ipaddress.com/github.com/">https://sites.ipaddress.com/github.com/</a><br>通过这个网站找到IP</p></li><li><p>打开hosts文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /<span class="keyword">private</span>/etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>将IP地址替换为第一步找到的IP，复制粘贴到Hosts文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP地址  github.com</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用开源软件"><a href="#使用开源软件" class="headerlink" title="使用开源软件"></a>使用开源软件</h1><p><a href="https://github.com/docmirror/dev-sidecar">dev-sidecar</a></p><p>然后使用按一下<code>ESC</code>，输入<code>:wq</code>保存并退出。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clean code</title>
      <link href="/posts/73a9e291/"/>
      <url>/posts/73a9e291/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h1><h2 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">realDaysPerIdealDay</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">const <span class="type">int</span> <span class="variable">WORK_DAYS_PER_WEEK</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="命令查询分离"><a href="#命令查询分离" class="headerlink" title="命令查询分离"></a>命令查询分离</h2><p>函数要么做某事，要么回答某事，但不能两者兼而有之。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String attribute, String value)</span>;</span><br></pre></td></tr></table></figure><p>该函数设置某个指定属性，如果成功就返回 ue，如果不存在那个属性则返回 false。这样就导致了以下语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>))...</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (attributeExists(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">    setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>);</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>最理想的参数数量是零(零参数函数)，其次是一《单参数函数)，再次是二 (双参数函数)，应尽量避免三 (三参数函数)。有足够特殊的理由才能用三个以上参数《多参数函数)-所以无论如何也不要这么做。</p><h2 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a>使用异常替代返回错误码</h2><p>从指令式函数返回错误码轻微违反了指令与询问分隔的规则。它鼓励了在 if语句判断中把指令当作表达式使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage(page) == E_OK)</span><br></pre></td></tr></table></figure><p>这不会引起动词&#x2F;形容词混淆，但却导致更深层次的嵌套结构。当返回错误码时，就是在要求调用者立刻处理错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage(page) == E_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.deleteReference(page.name) == E_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configKeys.deleteKey(page.name.makeKey()) == E_OK)&#123;</span><br><span class="line">            logger.log(<span class="string">&quot;page deleted&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.log(<span class="string">&quot;configKey not deleted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(<span class="string">&quot;deleteReference from registry failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    logger.log(<span class="string">&quot;delete failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> E_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要使用标记位做为函数参数"><a href="#不要使用标记位做为函数参数" class="headerlink" title="不要使用标记位做为函数参数"></a>不要使用标记位做为函数参数</h2><p>标记位是告诉你的用户这个函数做了不只一件事情。 函数应该只做一件事情。 如果你的函数因为一个布尔值 出现不同的代码路径， 请拆分它们。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createFile</span><span class="params">(String name,<span class="type">boolean</span> temp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./temp&quot;</span>+name);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">File</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createFile</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createTempFile</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./temp&quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式编程优于指令式编程"><a href="#函数式编程优于指令式编程" class="headerlink" title="函数式编程优于指令式编程"></a>函数式编程优于指令式编程</h2><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; programmerOutput=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">programmerOutput.add(<span class="number">500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">150</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1000</span>);</span><br><span class="line"><span class="type">int</span> totalOutput=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;programmerOutput.size();i++)&#123;</span><br><span class="line">    totalOutput+=programmerOutput.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; programmerOutput = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">programmerOutput.add(<span class="number">500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">150</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1000</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">totalOutput</span> <span class="operator">=</span> programmerOutput.stream()</span><br><span class="line">        .filter(programmer -&gt; programmer &gt; <span class="number">500</span>)</span><br><span class="line">        .mapToInt(programmer -&gt; programmer)</span><br><span class="line">        .sum();</span><br></pre></td></tr></table></figure><h2 id="避免负面条件"><a href="#避免负面条件" class="headerlink" title="避免负面条件"></a>避免负面条件</h2><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">isDOMNodeNotPresent</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isDOMNodeNotPresent(node)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">isDOMNodePresent</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDOMNodePresent(node)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="使用-getters-和-setters"><a href="#使用-getters-和-setters" class="headerlink" title="使用 getters 和 setters"></a>使用 getters 和 setters</h2><p><strong>错误示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class BankAccount &#123;</span><br><span class="line">    public int balance=1000;</span><br><span class="line">&#125;</span><br><span class="line">BankAccount bankAccount=new BankAccount();</span><br><span class="line">bankAccount.balance-=100;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blance=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBlance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> blance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBlance</span><span class="params">(<span class="type">int</span> blance)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(verifyIfAmountCanBeSetted(blance))&#123;</span><br><span class="line">                <span class="built_in">this</span>.blance = blance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">verifyIfAmountCanBeSetted</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BankAccount bankAccount=<span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line">    bankAccount.setBlance(<span class="number">2000</span>);</span><br><span class="line">    <span class="type">int</span> balance=bankAccount.getBlance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="不要返回Null值"><a href="#不要返回Null值" class="headerlink" title="不要返回Null值"></a>不要返回Null值</h2><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ItemRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> peristentStore.getItemRegistry();</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">existing</span> <span class="operator">=</span> registry.getItem(item.getID());</span><br><span class="line">            <span class="keyword">if</span> (existing.getBillingPeriod().hasRetailOwner()) &#123;</span><br><span class="line">                existing.register(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回 null值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 nul1 值，应用程序就会失控。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="keyword">if</span> (employees != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">        totalPay += e.getPay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">    totalPay += e.getPay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( .. there are no employees .. )</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要传递Null值"><a href="#不要传递Null值" class="headerlink" title="不要传递Null值"></a>不要传递Null值</h2><p>在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。除非 API要求你向它传递 null 值，否则就要尽可能避免传递 null 值。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">xProjection</span><span class="params">(Point p1, Point p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p2.x – p1.x) * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">xProjection</span><span class="params">(<span class="meta">@NotNull</span> Point p1, <span class="meta">@NotNull</span> Point p2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p2.x – p1.x) * <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恰当的做法就是禁止传入 null 值。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://github.com/shizhongyu/clean-code-java">https://github.com/shizhongyu/clean-code-java</a></li><li><a href="https://book.douban.com/subject/4199741/">代码整洁之道</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>var 和 let</title>
      <link href="/posts/bf2b1bc1/"/>
      <url>/posts/bf2b1bc1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a><strong>作用域：</strong></h1><ul><li><code>let</code> 具有块级作用域，只在声明的块或语句内部可见。</li><li><code>var</code> 具有函数级作用域，可在整个函数内部访问。</li></ul><p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的作用域区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">// 块级作用域内的变量</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">20</span>; <span class="comment">// 函数级作用域内的变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出 20</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 错误：x 未定义</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>x</code> 是使用 <code>let</code> 声明的变量，它只在 <code>if</code> 语句块内部可见。而 <code>y</code> 是使用 <code>var</code> 声明的变量，它在整个函数内部都可见。</p><span id="more"></span><h1 id="变量提升："><a href="#变量提升：" class="headerlink" title="变量提升："></a><strong>变量提升：</strong></h1><ul><li>使用 <code>let</code> 声明的变量不存在变量提升，必须在声明之后才能访问。</li><li>使用 <code>var</code> 声明的变量会被提升到其作用域的顶部，可以在声明之前访问。</li></ul><p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的变量提升区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 undefined</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 错误：y 未定义</span></span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用 <code>var</code> 声明的变量 <code>x</code> 在声明之前可以访问，但它的值为 <code>undefined</code>。而使用 <code>let</code> 声明的变量 <code>y</code> 在声明之前是不可访问的。</p><h1 id="重复声明："><a href="#重复声明：" class="headerlink" title="重复声明："></a><strong>重复声明：</strong></h1><ul><li>使用 <code>let</code> 声明的变量不允许在同一作用域内重复声明。</li><li>使用 <code>var</code> 声明的变量允许在同一作用域内重复声明，并且后面的声明会覆盖前面的声明。</li></ul><p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的重复声明区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// 错误：无法重新声明块级作用域的</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>; <span class="comment">// 重复声明，覆盖前面的声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包与 var：</strong><br>使用 <code>var</code> 声明的变量在闭包中具有共享的作用域。这意味着闭包内部的函数可以访问和修改外部函数中声明的变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>inner</code> 函数可以访问外部函数 <code>example</code> 中声明的变量 <code>x</code>。</p><p><strong>闭包与 let：</strong><br>使用 <code>let</code> 声明的变量在闭包中具有独立的作用域。每次迭代或调用闭包时，都会创建一个新的变量实例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>setTimeout</code> 函数中的回调函数形成了闭包。使用 <code>let</code> 声明的变量 <code>i</code> 在每次迭代时都会创建一个新的实例，因此每个闭包都能够访问到正确的值。</p><p>相比之下，如果我们使用 <code>var</code> 声明变量 <code>i</code>，则所有的闭包都会共享同一个 <code>i</code>，导致输出结果为 <code>5</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5, 5, 5, 5, 5</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在这个示例中，由于 <code>var</code> 声明的 <code>i</code> 在全局作用域中共享，所有的闭包都使用了相同的 <code>i</code> 值。</p><p>通过使用 <code>let</code> 声明变量，我们确保了每个闭包都可以访问到正确的值，而不会受到循环的影响。</p>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JIT和AOT</title>
      <link href="/posts/6c825f47/"/>
      <url>/posts/6c825f47/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AOT，JIT是什么"><a href="#AOT，JIT是什么" class="headerlink" title="AOT，JIT是什么"></a>AOT，JIT是什么</h1><p>程序主要有两种运行方式：静态编译与动态解释。</p><p>静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；<br>而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。</p><span id="more"></span><blockquote><p>AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。</p></blockquote><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>这两种编译方式的主要区别在于是否在“运行时”进行编译。</p><h1 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h1><p>JIT优点：</p><ol><li>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）</li><li>可以根据当前程序的运行情况生成最优的机器指令序列</li><li>当程序需要支持动态链接时，只能使用JIT</li><li>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</li></ol><p>JIT缺点：</p><ol><li>编译需要占用运行时资源，会导致进程卡顿</li><li>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡</li><li>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</li></ol><p>AOT优点：</p><ol><li>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗</li><li>可以在程序运行初期就达到最高性能</li><li>可以显著的加快程序的启动</li></ol><p>AOT缺点： </p><ol><li>在程序运行前编译会使程序安装的时间增加</li><li>牺牲Java的一致性</li><li>将提前编译的内容保存会占用更多的外存</li></ol><h1 id="JIT深度解析"><a href="#JIT深度解析" class="headerlink" title="JIT深度解析"></a>JIT深度解析</h1><p><img src="/../images/213b5edeabce499182278d7730227019.png" alt="213b5edeabce499182278d7730227019.png"></p><p>对于一个长期运行的Java进程来说，每次执行都要经过 解释器 将程序翻译成机器指令去执行，那么这个效率就不是很好，这也是为什么Java被吐槽慢的缘故，<br>所以为了解决这个问题，才出现了 JIT。对于一些热点代码（经常被执行的，for循环）的一些代码，在运行时，JVM会将这些代码编译成机器可以执行的机器码，并缓存起来，这样下次执行这些代码的时候，就不需要再经过 解释器去编译了，机器可以直接运行这段程序，提高性能，这个就被称为 即时编译器，简称 JIT编译器。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/cristianoxm/article/details/126032096">JIT VS AOT</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API测试</title>
      <link href="/posts/873cc8b2/"/>
      <url>/posts/873cc8b2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="9种API测试"><a href="#9种API测试" class="headerlink" title="9种API测试"></a>9种API测试</h1><span id="more"></span><p><img src="/../images/c53f283e-6834-45b6-beb9-57b10b2a22fd_1280x1664.webp" alt="c53f283e-6834-45b6-beb9-57b10b2a22fd_1280x1664.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端架构</title>
      <link href="/posts/926db354/"/>
      <url>/posts/926db354/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五种前端架构"><a href="#五种前端架构" class="headerlink" title="五种前端架构"></a>五种前端架构</h1><span id="more"></span><p><img src="/../images/F_38UuNbEAACWtu.jpeg" alt="F_38UuNbEAACWtu.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API安全技巧</title>
      <link href="/posts/55de1c2a/"/>
      <url>/posts/55de1c2a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="API-安全的-12-个技巧"><a href="#API-安全的-12-个技巧" class="headerlink" title="API 安全的 12 个技巧"></a>API 安全的 12 个技巧</h1><span id="more"></span><p><img src="/../images/45d16bfb-c541-4c01-8574-63cc39a5c560_1280x1664.webp" alt="45d16bfb-c541-4c01-8574-63cc39a5c560_1280x1664.webp"></p><h1 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p>云冲印<br><img src="/../images/bg2014051202.png" alt="bg2014051202.png"></p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。<br>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。<br>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。<br>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。<br>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p><p>OAuth就是为了解决上面这些问题而诞生的。</p><p><img src="/../images/v2-fccac16d440911894f2ff356064563e9_1440w.webp" alt="v2-fccac16d440911894f2ff356064563e9_1440w.webp"><br>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/posts/50daec4/"/>
      <url>/posts/50daec4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="8-种常用网络协议"><a href="#8-种常用网络协议" class="headerlink" title="8 种常用网络协议"></a>8 种常用网络协议</h1><span id="more"></span><p><img src="/../images/20231021-bf786236-f777-481b-ba9e-65921c16752e.gif" alt="20231021-bf786236-f777-481b-ba9e-65921c16752e.gif"></p><h1 id="Cookies-与-Sessions"><a href="#Cookies-与-Sessions" class="headerlink" title="Cookies 与 Sessions"></a>Cookies 与 Sessions</h1><p><img src="/../images/c05744c903f54153a28805cd182107bb~tplv-obj_1280_1664.gif" alt="c05744c903f54153a28805cd182107bb~tplv-obj_1280_1664.gif"></p><h1 id="URL-URI-URN"><a href="#URL-URI-URN" class="headerlink" title="URL, URI, URN"></a>URL, URI, URN</h1><p><img src="/../images/0_cU9y8hm7YEjkVZBJ.webp" alt="0_cU9y8hm7YEjkVZBJ.webp"></p><h1 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h1><p><img src="/../images/1704001549342.gif" alt="1704001549342.gif"></p><h1 id="在浏览器中输入一个网址后到底发生了什么？"><a href="#在浏览器中输入一个网址后到底发生了什么？" class="headerlink" title="在浏览器中输入一个网址后到底发生了什么？"></a>在浏览器中输入一个网址后到底发生了什么？</h1><p><img src="/../images/8d954f9b42c64ea0ab9be4567e38f523~tplv-obj_550_715.gif" alt="8d954f9b42c64ea0ab9be4567e38f523~tplv-obj_550_715.gif"></p><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p><img src="/../images/1475ba84-8106-4d61-924e-6403cfdc1074_1280x1664.webp" alt="1475ba84-8106-4d61-924e-6403cfdc1074_1280x1664.webp"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/663267550">用一张动图解释 8 种常用网络协议</a></li><li><a href="https://blog.bytebytego.com/p/ep80-explaining-8-popular-network">EP80: Explaining 8 Popular Network Protocols in 1 Diagram</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024.01日记</title>
      <link href="/posts/2916158c/"/>
      <url>/posts/2916158c/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="0834c5889d7aa6ef6e00c8dc67e765a6aecc3e7317ebde4a02b68390d886f89f">e6394f24cbc4b9c257a947e9735531ad08a3446c3c84a9d00b6eae5909cf293f146048ce73638583913e0501e468534034057e0e193891fad2388612f7731166073910ed811252225fc81de297ee7b23684bf0111ec8501f7610387b1894bc4d297da6ba09b0422463e1e2b5a72aff8e9d2599d9fb34f0f81a48a81ae9f4c8e286a642f41c666ad46697b097c8b9a222da9bf869e27afc95699902da7e4b01796f1cbae0e5d8ba7cf14aac019f4a3f0210487bc850c3050568acd234ed60ed305d35cf714ad8586a2fdeb969af3c3719d1dbd5ac54688acec2cd2dae259e29435480aae4bd8fe3f64108385c6742145f65bd5bc637ab0c01ebfb94f8c28c2dfd3ee303b5e5c15e13bbbd325c7ca40ee4182435d4974ffd1a7dcc36721700dbec48ff583e2cda993abaa034d8269b7aa13bbbb7942ed28ccba7c181f3215ddc1b039fdb72d8f39bf30d6716129c76f8d1c4434d71159dbd9109ec4ed7b540e647de22ab6dcdddf19e15b14e69479da32eaaed4458c0a427accba441720bbd812139b5afc2a73ae057580cd727e0724e5534a154f928663a6dc7a266c9b25f59663d094419bfb07e353417e38283f04553d3ec6f13faaedad7cdb38037bad57e3bb5f335c6612ca24b9b6423c7cf0f2214f1deeb29d5c618e22c8539b5bb01679a54c9bafcd304efc13407abd4d8692bf2aec29f8bf4cd2531b613a2deaac9f90107d969551eefe53cc1eae9ee16810c6e2cd61539c9a21c95c03862266a5236d41f2300b5832ecf34d26764cc7a9ad58c773582d750581051a116fcf055b8627445ea23dfad2e3d63c1b5a6bb8fec4a997c537929e76672a85a2eddc3397f335135ecc89fa79fb15fbb43932dc20d8277114dfe97bbedf315eec923579f791507eebef89982cdd39dd81c87a2ce4fe2323dacf46152ad7fe40831f3970cf9b89bb8421c73844bf978e7528ebe62d5461beb549a9bbb94ffc7e4baa76a5a08aba84e8bf8384fb8d6e24600b5ac64882eff10d9feaa5d41ad84554b08f1f79ccec40545735f1f73a12780e96f3aaf66b4e99f1f44a05efa2831ab9a8583f57e966b5b4283ecb6362ccc83c674c6dbca8a011d8231f4ce3a653eabfde09ff1cf879f5e4d6ad5ef339097d9c6038108064dd538ec20ae242994e6b9bf594751caefb0d8ca81a833f9d5d8d44505def00f4eec9c8de0721f9c50c5c70507664eff0f5f90b9b90010a00178a7bb30cd61639b6e73f0957ed62d0c8e1054bb1f867a793197da0c8a1dee9e04dfe618672d3e0d093b2997868260b35a86db6fa3291b4890c7b58b7829f2f11402cc23a18cca46b5e4e0f47bc917802c9b500b4148cc442df4b07baab1be5477f2e444bd5eab8a5820553e06a69ffc95902db7ae9b5611743f8b7ad9b4c369ec7d12fc30b724df4f69525ca599fa217d1d2f37168bfdc4450365a4e13ac7f7de7dcc5279629345d4114e2916b5aa7b7f5df5e219a9bb9d64115cd8a25627a06f61d7ac967e9a0019e3d8d9a818cee4dabd4852e742dc326f7cbf79ce43a44b6c4bfb9d8febc573b35a3a8dc051d0d95118c671bdaab1cbe151121333313e2ed58472a8894c0ed88d10d33065c30ed0418ab234a25bf522d4e3920e52e15dd586ff5c00509d56ec1ec145dc6021971d4a7630de6490194e65889c56e6f014c68d24d8ea599f53ed0c5698ecaa2aa2224f4c981ab11c794314b832bb35a9672cf657b33f9a62e140d283bc2f4cd0efb1104b9e5ef9e5e7f4dc4a127c834db67ac363b5fb939ec89d6b96e550377b3dc4620a61974ad2b3819966aaab842f97dc7bd6e1d6e14bdea4ba8ea028432409d0480f1918f8712497b87b1151229397977cda49de466d971ef83ad0c21c90acfad03430bb49ab7d060ad87bdd30d5d02dd3d2c52de65289ac09ba3de0a1159c4684b92dd6fcd56251773dee8e600354699caed0ba6f39b2cd661e15d026af8f7e8daceb9fd46844356bf4802e6eb15ddd670513ac1172f87466ca20e5ea0fcf1bac09395306f7a0124b3c17037b9fb31b8eb2a758164136877cc99cb23b7e94e1ada1b8e9828cca2ad298b49d21e45eb3def6b98fe803aa745edbc64e528a55b95c0cc234f41af6aa68123993794541934cd3fa4129a5857e83b7954614e525924f436b876b2ef29129c7dba6ed7310a1cb088baf7cedf17f4c0fe977d1fb479bffa8341ce1a214617f4ad93bbc0fac35a0a59e096a20fe22e9c6e4a2b7c45cb0dd32b499c02c3a460bdc48751487aa32db50303f59f679684a306235f48a8b1a8026e608409f54c6dc0bfacf5398bfc652cb3ac6418997744818c9f7926eafbcc5e9643ba095c174b54cf78cc3a7aa5c35100d0e1fb49f78b67ae8d2c566bdf7dc4388a6456f07f9308c2f4e73973b21a07b33b744562475199f821946d97b234cbe2b22b2b0e186eb522222fa0724020e8f822fa634d1701d16deff034e8e287d06db3a96d271eb1003c91970e88a5db9186a799b5df2891f480240dc1a660a49f132d6882ece0c89b61d99c1bcf3859537f23b610e46de3139fbd4f06dbba47a6089f08e585388b4ab176e209248a2d6965fe238d183d850ed102e9c9fdcd72acf089dce3144a3cb8d229acb643a2d2a1c016a2779784c8c2cc7d4f31edd37a4747b8201c58963ac50449b6d56c22a78007a00d3fda8a73d8efbef4b8fa0ef5692bc2043b3beab7b916cbed83175a51212bcfac9414c166faaef73788704278e089838eaf49924a6c228f7645c99eaa0a49308072256e2bdd70cbaade4a5a710aaf0427e5a59efad330621e33794a2de38d41c70a1df633b154a4394a7c8ac57f7c9eaa27de115bf78eaf0a09834f40322cc1e4ddec2dd5f009d70bbc8f6db660c58a05df5c39bb3572116e6ca912ff3fc3728e58b580c6204b68a288b7282ff6c9447a28f77998a3e987aa1fabc6e01881993ce2175462b6e6fce7001886ed9d7feebe295d7d3be528a4679b1b0c37287d4f066f3ac0a4b44a7a9c206437e06910c1387b9d55c665209a7e5dc3e039e48a6e08f80c581ef0db43e5aa86be088b259d3106ccb42ff7d1bcc87fe29994b2aa30b4676a8cdf0b5e78289b447380e13ced7b7a735c24a348f32496854ae856a59b41d07c08b2df0cda9f921b47ca59ece7254de4d2d615ccbe938c921c85251db9858f6859b35b5693cc43f60be406e2905d3b1f1917f19450014cc9813c2da76232ca9ebd6816ebe21d2c0a90d7701aff782d5a319f954ac0cfec318624e17cf8601697a8d938876ce2a71ef130438eec39498e51ea109109d3c26062ddb4a8f7d0d01bd74f74396a794387c9affad6ebd547f52d5144e6aa247a312a719275a88435f18acef80fb584f7ec4cb6a9d771699193bd3958119e1e3fb3a5de68f3c0983a1a6e68b5e5060d7016ddc3250beb67dde8889a5a87e3a0255260de422cb396f00812a936473179d9846dc8807a7abb25a0f4cd1cefdc92a28e4fbf1b1b6308e6539318fa908386651d796ebb8583621fc0c7bef4794a6d706a8ffa7dfd6249926bea70dbea83efe254888d0ef8960f21ea04a419fd85a060e73af37f16a31519cd963921acf334b94ae8cdc9b8d5b04fe1c7fcfb8d0034416aff793d48c5e3eb4ea0950a9f5d8f9ad7a89927793986173189f6677671148bf38890934041cca828e69bdd28c046e0ab431dab4bcbb5c8b08659e816c2a5a85d9884a6c6c8833a0ba23150b37efc76def2e666cd12dc834f459a43b57ed0737597dd0951c3804024d0df3712fbc01bdf673519fa629d9bb44e36d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V8技能树</title>
      <link href="/posts/e4409905/"/>
      <url>/posts/e4409905/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是-V8"><a href="#什么是-V8" class="headerlink" title="什么是 V8?"></a>什么是 V8?</h1><p>V8 是 JavaScript 虚拟机的一种。将人类能够理解的编程语言 JavaScript，翻译成机器能够理解的机器语言。</p><span id="more"></span><p><img src="/../images/download.jpg" alt="download.jpg"></p><h1 id="V8编译流水线"><a href="#V8编译流水线" class="headerlink" title="V8编译流水线"></a>V8编译流水线</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(1).jpeg" alt="下载 (1).jpeg"></p><ol><li>初始化基础环境；</li><li>解析源码生成 AST 和作用域；</li><li>依据 AST 和作用域生成字节码；</li><li>解释执行字节码；监听热点代码；</li><li>优化热点代码为二进制的机器代码；</li><li>反优化生成的二进制机器代码。</li></ol><p>这里你需要注意的是，JavaScript 是一门动态语言，在运行过程中，某些被优化的结构可能会被 V8 动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。</p><p>编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内<br>联缓存等等。</p><p>要想充分了解 V8 是怎么工作的，除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是事件循环系统和垃圾回收机制。</p><h1 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(2).jpeg" alt="下载 (2).jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
